from Marvell.PySub20.Common.Types import I2CMode
from Marvell.PySub20.sub20_i2c_handle import *
from Marvell.PySub20.Common.Constants import *
from time import sleep


class PySub20Provider(object):
    def __init__(self):
        self._connected = None
        self._sub20_hndl = Sub20Handle()
        self._config = Sub20Config()

    def Connect(self, serial_num: int):
        """

        @param serial_num: Connection key, for Sub20 it's a Sub20 Device Address
        @return: On success function returns True. Otherwise Exception will be raised.
        """
        try:
            if type(serial_num) is not int :
                raise Exception(f"Wrong format. Key should be int serial number.")
            self._sub20_hndl.Init_Sub_Device(serial_num)
            # Ping the connection
            self._sub20_hndl.openSub20()
            self._sub20_hndl.closeSub20()
            self._connected = True
        except Exception as e:
            self._connected = False
            if type(serial_num) is int:
                sn = hex(serial_num)
            else:
                sn = str(serial_num)
            raise Exception(f"Failed to connect SUB20 serial number {sn}. Error: {str(e)}")

    def Disconnect(self):
        """

        @return: On success function returns None. Otherwise Exception will be raised.
        """
        try:
            self._sub20_hndl.Disconnect()
        finally:
            self._connected = False

    def I2C_Read(self, slaveAddr, memAddr, memAddrSz, size):
        """
        Note: If memAddrSz is zero "Memory Address Write" stage will be skipped.

        @param slaveAddr: Slave Address
        @param memAddr:  Memory Address. Will be shifted out in "Memory Address Write" stage MSB first
        @param memAddrSz: Memory Address size bytes
        @param size:  Read data size bytes.
        @return: Buffer read data if success. Otherwise Exception will be raised.
        """
        e_msg = ""
        for i in range(3):
            try:
                #data = self._sub20_hndl.Read(slaveAddr, size, memAddr, memAddrSz)
                data = self._sub20_hndl.subI2CRead( slaveAddr, memAddr, memAddrSz, size)
                return list(data)
            except Exception as e:
                e_msg = str(e)
                sleep(self._sub20_hndl.wait_time / 1000)
        # return None
        raise Exception(f"Failed to read I2C.\n Error: {e_msg}")

    def I2C_Write(self, slaveAddr, memAddr, memAddrSz, buffer, size):
        """
        Note: If memAddrSz is zero "Memory Address Write" stage will be skipped.

        @param slaveAddr: Slave Address
        @param memAddr:  Memory Address. Will be shifted out in "Memory Address Write" stage MSB first
        @param memAddrSz: Memory Address size bytes
        @param buffer: Buffer for data to be written (Array of data)
        @param size:  Write data size bytes.

        @return: On success function returns True. Otherwise Exception will be raised.
        """
        for i in range(3):
            #bytes_written = self._sub20_hndl.Write(slaveAddr, size, buffer)
            bytes_written = self._sub20_hndl.subI2CWrite(slaveAddr, memAddr, memAddrSz, buffer, size)
            if bytes_written == size:
                return True
            else:
                sleep(self._sub20_hndl.wait_time / 1000)

        raise Exception(f"Failed to Write I2C.")

    def I2C_Scan(self):
        """

        @return: On success function returns list of slave device addresses . Otherwise Exception will be raised.
        """

        raise NotImplemented("Sub20 I2C_Scan function NotImplemented")

    # def _Read(self, addr, nBytes, memoryAddr=0, memoryAddrSize=0):
    #     """
    #     basic i2c read
    #     """
    #     e_msg = ""
    #     for i in range(3):
    #         try:
    #             data = self.i2c_hndl.Read(addr, nBytes, memoryAddr, memoryAddrSize)
    #             return data
    #         except Exception as e:
    #             e_msg = str(e)
    #             sleep(self.i2c_hndl.wait_time / 1000)
    #     # return None
    #     raise Exception(e_msg)

    # def _Write(self, addr: int, nBytes: int, data: bytes):
    #     """
    #     basic i2c write
    #     """
    #     for i in range(3):
    #         bytes_written = self.i2c_hndl.Write(addr, nBytes, data)
    #         if bytes_written == nBytes:
    #             return True
    #         else:
    #             sleep(self.i2c_hndl.wait_time / 1000)

    # def ReadData(self, addr: int, nBytes: int):
    #     """
    #     read data with Marvell convention, shift right the address
    #     confirmed. Data read stage. without Memory Address Write
    #     """
    #     if not self.connected:
    #         raise Exception('Sub20 is not connected')
    #
    #     addr = addr >> 1
    #     return self.Read(addr, nBytes)

    # def WriteByte(self, addr: int, data: int):
    #     """
    #     write one byte with Marvell convention, shift right the addr
    #     confirmed. Data write stage. without Memory Address Write
    #     """
    #     if not self.connected:
    #         raise Exception('Sub20 is not connected')
    #
    #     addr = addr >> 1
    #     return self.Write(addr, 1, bytes([data]))

    # def WriteArray(self, devAddr: int, subAddr: int, nBytes: int, data: bytes):
    #     """
    #     write more than one byte
    #     confirmed. add the address to the data write stage, as one long transaction
    #     """
    #     if not self.connected:
    #         raise Exception('Sub20 is not connected')
    #
    #     #   write sub-address
    #     sub_addr_data = bytes().join([bytes([subAddr]), data])
    #
    #     devAddr = devAddr >> 1
    #     return self.Write(devAddr, 1 + nBytes, sub_addr_data)

    # def ReadArray(self, devAddr: int, subAddr: int, nBytes: int):
    #     """
    #     read more than one byte
    #     confirmed. in use in IO.two transactions: write the address then write the data
    #     """
    #
    #     if not self.connected:
    #         raise Exception('Sub20 is not connected')
    #     devAddr = devAddr >> 1
    #     self.Write(devAddr, 1, bytes([subAddr]))
    #     data = self.Read(devAddr, nBytes)
    #     return data

    # def ReadI2CArray(self, addr: int, nBytes: int, memoryAddr: int, memoryAddrSize: int):
    #     """
    #     execute i2c read -> basic with wait logic
    #     confirmed for i2c read. address and data in the same transaction
    #     """
    #     if not self.connected:
    #         raise Exception('Sub20 is not connected')
    #     addr = addr >> 1
    #     return self.Read(addr, nBytes, memoryAddr, memoryAddrSize)

    def setLog(self, logLevel: int):
        self._sub20_hndl.setLog(logLevel)

    # def genericRead(self, devAddr: int, subAddrValid: int, subAddr: int, nBytes: int):
    #     if subAddrValid or nBytes > 1:
    #         data = self.ReadArray(devAddr, nBytes, subAddr)
    #         val = 0
    #         for i in range(len(data)):
    #             val += data[i] << (i * 8)
    #     else:
    #         data = self.ReadData(devAddr, 1)
    #     return data

    # def genericWrite(self, devAddr: int, subAddrValid: int, subAddr: int, nBytes: int, value: int):
    #     """
    #     confirmed for i2c write- c we can skip Memory Address Write, and add
    #     the address to the data write stage
    #     """
    #     if subAddrValid:
    #         data = bytes()
    #         for i in range(nBytes):
    #             data = bytes().join([data, bytes([(value >> (i * 8)) & 0xFF])])
    #
    #         for i in range(4 - nBytes):
    #             data = bytes().join([data, bytes([0])])
    #
    #         return self.WriteArray(devAddr, subAddr, nBytes, data)
    #     else:
    #         self.WriteByte(devAddr, value)

    def SetI2CConfigParams(self, lptNum=None, frequency=None, mode=None, waitTime=None):
        self._config.updateConfig(lptNum, frequency, mode, waitTime)
        self._sub20_hndl.SetI2CConfigParams(self._config.lptNum, self._config.frequency, self._config.waitTime,
                                            self._config.mode, i2cInterface=None)

    def GetConnectedSub20Ids(self):
        if not self._connected:
            self.SetI2CConfigParams()
            self._connected = True
        return self._sub20_hndl.GetConnectedSub20Ids()


class Sub20Config(object):
    def __init__(self, lptNum=NULL, frequency=50, mode=I2CMode.I2C_NORMAL_MODE, waitTime=30):
        self.lptNum = lptNum
        self.frequency = frequency
        self.mode = mode
        self.waitTime = waitTime

    def updateConfig(self, lptNum=None, frequency=None, mode=None, waitTime=None):
        if lptNum:
            self.lptNum = lptNum
        if frequency:
            self.frequency = frequency
        if mode:
            self.mode = mode
        if waitTime:
            self.waitTime = waitTime


