from ctypes import *
import os

from Marvell.EMClientPy.src.Common.Constants import NULL


DLL_NAME = 'Sub20'


def toHex(s):
    return int(s, 16)


def toHexStr(n):
    return hex(n)


class Sub20Wrapper(object):
    log_level = 0
    sub_hndl = None
    sub_dev = None
    wait_time = None

    def __init__(self):
        interpreter_dir_name = "System32"
        dll_full_path = os.path.join(os.environ["SystemRoot"], interpreter_dir_name, DLL_NAME)
        self._sub20_APIs_Lib = cdll.LoadLibrary(dll_full_path)
        self._init_handlers()

    def _init_handlers(self):
        self._init_sub_find_devices()
        self._init_sub_open()
        self._init_sub_get_product_id()
        self._init_sub_get_serial_number()
        self._init_sub_i2c_freq()
        self._init_sub_i2c_read()
        self._init_sub_i2c_write()
        self._init_sub_close()
        self._init_sub_errno()
        self._init_sub_strerror()

    def _init_sub_find_devices(self):
        self.sub_find_devices = self._sub20_APIs_Lib.sub_find_devices
        self.sub_find_devices.argtypes = [c_void_p]
        self.sub_find_devices.restype = c_void_p

    def _init_sub_open(self):
        self.sub_open = self._sub20_APIs_Lib.sub_open
        self.sub_open.argtypes = [c_void_p]
        self.sub_open.restype = c_void_p

    def _init_sub_get_product_id(self):
        self.sub_get_product_id = self._sub20_APIs_Lib.sub_get_product_id
        self.sub_get_product_id.argtypes = [c_void_p, c_char_p, c_int]

    def _init_sub_get_serial_number(self):
        self.sub_get_serial_number = self._sub20_APIs_Lib.sub_get_serial_number
        self.sub_get_serial_number.argtypes = [c_void_p, c_char_p, c_int]

    def _init_sub_i2c_freq(self):
        self.sub_i2c_freq = self._sub20_APIs_Lib.sub_i2c_freq
        self.sub_i2c_freq.argtypes = [c_void_p, POINTER(c_int)]
        self.sub_i2c_freq.restype = c_int

    def _init_sub_i2c_read(self):
        self.sub_i2c_read = self._sub20_APIs_Lib.sub_i2c_read
        self.sub_i2c_read.argtypes = [c_void_p, c_int, c_int, c_int, c_char_p, c_int]
        self.sub_i2c_read.restype = c_int

    def _init_sub_i2c_write(self):
        self.sub_i2c_write = self._sub20_APIs_Lib.sub_i2c_write
        self.sub_i2c_write.argtypes = [c_void_p, c_int, c_int, c_int, c_char_p, c_int]
        self.sub_i2c_write.restype = c_int

    def _init_sub_close(self):
        self.sub_close = self._sub20_APIs_Lib.sub_close
        self.sub_close.argtypes = [c_void_p]

    def _init_sub_errno(self):
        self.sub_errno = lambda: c_int.in_dll(self._sub20_APIs_Lib, "sub_errno")

    def _init_sub_strerror(self):
        self.sub_strerror = self._sub20_APIs_Lib.sub_strerror
        self.sub_strerror.argtypes = [c_int]
        self.sub_strerror.restype = c_char_p

    def __del__(self):
        self.CloseAdaptor()

    def raiseSub20RuntimeError(self, msg):
        message = msg + ", Message=" + self.getErrorMessageFromDLL()
        raise RuntimeError(message)

    def getErrorMessageFromDLL(self):
        errno = self.sub_errno().value
        errorMsg = self.sub_strerror(errno).decode('utf-8')
        return 'Error number: ' + str(errno) + ' - ' + errorMsg

    def RegisterClient(self, clientName):
        return 0

    def UnregisterClient(self):
        pass

    def FindConnectedDevice(self, lptNum: int):
        dev = 0
        try:
            while True:
                dev = self.sub_find_devices(dev)
                if dev:
                    hndl = self.sub_open(dev)
                    if hndl:
                        serialNumber = self.getSerialNumber(hndl)
                        if serialNumber == lptNum:
                            self.sub_close(hndl)
                            return dev
                    self.sub_close(hndl)
                else:
                    return NULL
        except Exception as e:
            msg = "Error in sub_find_devices, " + str(e)
            self.raiseSub20RuntimeError(msg)

    def SetI2CConfigParams(self, lptNum, freq, waitTime, i2cMode, i2cInterface, errMsg=''):
        if lptNum == NULL:
            self.sub_dev = NULL
        else:
            self.sub_dev = self.FindConnectedDevice(lptNum)
            if self.sub_dev == 0:
                msg = "Sub20, serial number= " + toHexStr(lptNum) + ", could not be found."
                self.raiseSub20RuntimeError(msg)

        self.openSub20()

        if self.sub_hndl == 0:
            msg = "Error in sub_open"
            self.raiseSub20RuntimeError(msg)

        self.wait_time = waitTime
        sub_freq = pointer(c_int(freq * 1000))

        for i in range(100):     # retry
            ret = self.sub_i2c_freq(self.sub_hndl, sub_freq)
            if ret == 0:
                self.closeSub20()
                return True

        self.closeSub20()
        msg = "sub_i2c_freq failed."
        self.raiseSub20RuntimeError(msg)

    def GetConnectedSub20Ids(self):
        dev = self.sub_find_devices(0)
        lst = []
        try:
            while dev:
                hndl = self.sub_open(dev)
                serialNumber = self.getSerialNumber(hndl)
                lst.append(serialNumber)
                self.sub_close(hndl)
                dev = self.sub_find_devices(dev)
            return lst
        except Exception as e:
            msg = "Error in sub_find_devices, " + str(e)
            self.raiseSub20RuntimeError(msg)

    def CloseAdaptor(self):
        if self.sub_hndl != 0:
            self.sub_close(self.sub_hndl)
        self.sub_hndl = NULL
        self.sub_dev = NULL

    def Disconnect(self):
        self.CloseAdaptor()

    def Read(self, slaveAddr, nBytes, memoryAddr=0, memoryAddrSize=0):
        """
        Perform complete I2C master read transaction with optional memory address write (when memoryAddrSize != 0)
        :param slaveAddr: Slave Address
        :param nBytes: Read data size bytes.
        :param memoryAddr: Memory Address. Will be shifted out in "Memory Address Write" stage MSB first
        :param memoryAddrSize: Memory Address size bytes
        :return: On success function returns data read
        :raise: I2CRead RuntimeError
        """
        self.openSub20()
        try:
            data = self.subI2CRead(slaveAddr, memoryAddr, memoryAddrSize, nBytes)
        finally:
            self.closeSub20()
        if self.log_level == 1:
            msg = "i2c read slaveAddr=" + toHexStr(slaveAddr) + " bytes=" + str(nBytes)
            print(msg)
        return data

    def Write(self, addr: int, nBytes: int, data: bytes):
        """
        Perform complete I2C master write transaction
        :param slaveAddr: Slave Address
        :param data: The data to be written
        :param nBytes: Write data size bytes
        :return: Number of data bytes written successfully
        :raise: I2CWrite RuntimeError
        """
        self.openSub20()
        try:
            self.subI2CWrite(addr, nBytes, data)
        finally:
            self.closeSub20()
        if self.log_level == 1:
            msg = "i2c write slaveAddr=" + toHexStr(addr) + " bytes=" + str(nBytes)
            print(msg)
        return nBytes

    def IsSub20Adaptor(self):
        return False

    def setLog(self, log_level):
        self.log_level = log_level

    def openSub20(self):
        self.sub_hndl = self.sub_open(self.sub_dev)

    def closeSub20(self):
        self.sub_close(self.sub_hndl)
        self.sub_hndl = NULL

    def getSerialNumber(self, hndl):
        s = create_string_buffer(8)
        self.sub_get_serial_number(hndl, s, 8)
        return toHex(s.value)

    def subI2CRead(self, addr, ma, ma_sz, nBytes):
        data = create_string_buffer(nBytes)
        retVal = self.sub_i2c_read(self.sub_hndl, addr, ma, ma_sz, data, nBytes)

        if retVal != 0:
            msg = "sub_i2c_read failed to read data from address " + toHexStr(addr)
            self.raiseSub20RuntimeError(msg)

        return data.raw

    def subI2CWrite(self, addr: int, nBytes: int, data: bytes):
        dataToWrite = create_string_buffer(data)
        retVal = self.sub_i2c_write(self.sub_hndl, addr, 0, 0, dataToWrite, nBytes)

        if retVal != 0:
            msg = "sub_i2c_write failed to write data to address " + toHexStr(addr)
            self.raiseSub20RuntimeError(msg)

        return nBytes
