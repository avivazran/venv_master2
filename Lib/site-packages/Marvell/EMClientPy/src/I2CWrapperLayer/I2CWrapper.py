from .ABC_I2CWrapper import ABC_I2CWrapper
from Marvell.EMClientPy.src.Common.Types import I2CMode, BoardPowerModeEnum, I2cInterfaceEnum
# from Marvell.EMClientPy.src.ProvidersBaseLayer.Sub20Wrapper import *
from Marvell.EMClientPy.src.Common.Constants import *
from time import sleep
try:
    from Marvell.PyI2C.PyI2C import PyI2CInterface
except Exception as e:
    from Marvell.EMClientPy.Common.ImportExternal import import_external
    import_external('PyI2C')
    from Marvell.PyI2C.PyI2C import PyI2CInterface


class I2CWrapper(ABC_I2CWrapper):
    def __init__(self):
        self.connected = False
        self._i2c_interface = None# PyI2CInterface()  # TODO: change it to be the I2CInterface of type PyI2CInterface
        self.config: Sub20Config = Sub20Config()
        # TODO: ADD check decorator for i2cinterface (wrapper)

    def Connect(self, connection_id):
        self._i2c_interface.Connect(connection_id)
        self.connected = True
        return GT_OK

    def Disconnect(self):
        try:
            self._i2c_interface.Disconnect()
        finally:
            self.connected = False
        # TODO: Add logic as required for proper functionality

    def Read(self, addr, nBytes, memoryAddr=0, memoryAddrSize=0):
        e_msg = ""
        for i in range(3):
            try:
                data = self._i2c_interface.I2C_Read(addr, memoryAddr, memoryAddrSize, nBytes)
                return data
            except Exception as e:
                e_msg = str(e)
                sleep(self.config.waitTime / 1000)
        # return None
        raise Exception(e_msg)

    def Write(self, addr: int, nBytes: int, data: bytes):
        for i in range(3):
            data = list(data)
            bytesWritten = self._i2c_interface.I2C_Write(addr, 0, 0, data, nBytes) # check that we don't use Write address phase
            if bytesWritten:
                return True
            else:
                sleep(self.config.waitTime / 1000)

        return False
    # TODO: add set i2c interface to define the interface that will execute the commands
    def InitI2cInterface(self, i2cInterface: I2cInterfaceEnum = I2cInterfaceEnum.I2C_USB):
        self._i2c_interface = PyI2CInterface()
        self._i2c_interface.Init(i2cInterface)

    def SetI2CConfigParams(self, lptNum=None, frequency=None, mode=None, waitTime=None):
        self.config.updateConfig(lptNum, frequency, mode, waitTime)
        # self._i2c_interface.SetI2CConfigParams(self.config.lptNum, self.config.frequency, self.config.waitTime,
        #                                        self.config.mode, self.i2cInterface)

        self._i2c_interface.Execute('SetI2CConfigParams', self.config.lptNum, self.config.frequency, self.config.waitTime,self.config.mode)

    def GetConnectedSub20Ids(self):
        if not self.connected:
            self.SetI2CConfigParams()
            self.connected = True
        return self._i2c_interface.Execute('GetConnectedSub20Ids')
        # return self._i2c_interface.GetConnectedSub20Ids()

    def ReadData(self, addr: int, nBytes: int):
        if not self.connected:
            raise Exception('Sub20 is not connected')

        addr = addr >> 1
        return self.Read(addr, nBytes)

    def WriteByte(self, addr: int, data: int):
        if not self.connected:
            raise Exception('Sub20 is not connected')

        addr = addr >> 1
        return self.Write(addr, 1, bytes([data]))

    def ReadI2CArray(self, addr: int, nBytes: int, memoryAddr: int, memoryAddrSize: int):
        if not self.connected:
            raise Exception('Sub20 is not connected')
        addr = addr >> 1
        return self.Read(addr, nBytes, memoryAddr, memoryAddrSize)

    def ReadArray(self, devAddr: int, subAddr: int, nBytes: int):
        if not self.connected:
            raise Exception('Sub20 is not connected')
        devAddr = devAddr >> 1
        self.Write(devAddr, 1, bytes([subAddr]))
        data = self.Read(devAddr, nBytes)
        return data

    def WriteArray(self, devAddr: int, subAddr: int, nBytes: int, data: bytes):
        if not self.connected:
            raise Exception('Sub20 is not connected')

        #   write sub-address
        subAddrData = bytes().join([bytes([subAddr]), data])

        devAddr = devAddr >> 1
        return self.Write(devAddr, 1 + nBytes, subAddrData)

    def setLog(self, logLevel: int):
        self._i2c_interface.SetLog(logLevel)

    def genericRead(self, devAddr: int, subAddrValid: int, subAddr: int, nBytes: int):
        # if subAddrValid or nBytes > 1:
        #     data = self.ReadArray(devAddr, subAddr,nBytes)
        #     val = 0
        #     for i in range(len(data)):
        #         val += data[i] << (i * 8)
        # else:
        #     data = self.ReadData(devAddr, 1)
        # return data
        devAddr = devAddr << 1 # ReadI2CArray take care to return it back to addr
        data = self.ReadI2CArray(devAddr, nBytes, subAddr, subAddrValid)
        val = 0
        for i in range(len(data)):
            val += data[i] << (i * 8)
        return val


    def genericWrite(self, devAddr: int, subAddrValid: int, subAddr: int, nBytes: int, value: int):
        if subAddrValid:
            data = bytes()
            for i in range(nBytes):
                data = bytes().join([data, bytes([(value >> (i * 8)) & 0xFF])])

            for i in range(4 - nBytes):
                data = bytes().join([data, bytes([0])])

            return self.WriteArray(devAddr, subAddr, nBytes, data)
        else:
            self.WriteByte(devAddr, value)


class Sub20Config(object):
    def __init__(self, lptNum=NULL, frequency=50, mode=I2CMode.I2C_NORMAL_MODE, waitTime=30):
        self.lptNum = lptNum
        self.frequency = frequency
        self.mode = mode
        self.waitTime = waitTime

    def updateConfig(self, lptNum=None, frequency=None, mode=None, waitTime=None):
        if lptNum:
            self.lptNum = lptNum
        if frequency:
            self.frequency = frequency
        if mode:
            self.mode = mode
        if waitTime:
            self.waitTime = waitTime
