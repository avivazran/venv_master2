# from __future__ import annotations
import re
from math import pow
from time import sleep

from Marvell.EMClientPy.src.ElectricalManagmentModels.Base_Models import VoltageControl, ItemType
from Marvell.EMClientPy.src.ElectricalManagmentModels.Models_Validator import Models_Validator
from Marvell.EMClientPy.src.ElectricalManagmentModels.Model_Enums import ItemTypeEnum
from Marvell.EMClientPy.src.Common.Utilities import TwosComplement
from Marvell.EMClientPy.src.Common.Constants import *
from typing import List


class PS:
    pass


class PS(ItemType):
    type_: str = ''
    modules_phase = 0
    phase_multiplier = 1
    def_vref: int = 800
    valid = False
    desc = ''
    measure_type = None
    min_vol = 0.0
    max_vol = 0.0
    def_vol = 0.0
    vnom_factory_default = 0.0
    margin_selection = ''
    slaveAddr = None
    voltage_ctrl: VoltageControl = None
    _debug = False

    def __init__(self, elm, parent, connId):
        super(PS, self).__init__(elm, parent, connId, ItemTypeEnum.PS)
        if elm is not None:
            self.type_ = self.getFirstChildElement('type')
            self.modules_phase = Models_Validator.nonNegativeInteger(self.getFirstChildElement('modules_phase'))
            self.valid = Models_Validator.validType(self.getFirstChildElement('modules_phase'))
            self.desc = self.getFirstChildElement('desc')
            self.measure_type = Models_Validator.measureType(self.getFirstChildElement('measure_type'))
            self.min_vol = Models_Validator.voltType(self.getFirstChildElement('min_vol'))
            self.max_vol = Models_Validator.voltType(self.getFirstChildElement('max_vol'))
            self.def_vol = Models_Validator.voltType(self.getFirstChildElement('def_vol'))
            self.vnom_factory_default = self.def_vol
            self.margin_selection = Models_Validator.marginSelection(self.getFirstChildElement('margin_selection'))
            sa = self.getChildrenElements('slaveAddr', 4)
            self.slaveAddr = []
            for s in sa:
                self.slaveAddr.append(Models_Validator.addrType(s.text))
            self.vc = VoltageControl(self.getFirstChildElement('voltage_ctrl', None), self, 0)

            # phase_multiplier is an optional tag
            mul = Models_Validator.voltType(self.getFirstChildElement('phase_multiplier'))
            if mul is not None:
                self.phase_multiplier = mul
            else:
                self.phase_multiplier = 1
            dvref = Models_Validator.voltType(self.getFirstChildElement('def_vref'))

            if dvref is not None:
                self.def_vref = dvref
            else:
                self.def_vref = 800

    """*********************************************************************************
    PS EM APIs
    *********************************************************************************"""

    @staticmethod
    def getPSsIDs(board) -> List[int]:
        res: List[int] = []
        for ps in PS._getPSsElements(board):
            res.append(ps.id)
        return res

    @staticmethod
    def getPSInfo(board, provider, psId):
        ps = PS._getPSElement(board, psId)
        ps.setProvider(provider)
        return ps.getInfo()

    @staticmethod
    def setVdd_PMBusValue(board, provider, psId, value: float):
        ps = PS._getPSElement(board, psId)
        if not ps.isVddInValidRange(value):
            raise Exception('Vdd value you are trying to set is out of valid range for current PS')
        ps.setProvider(provider)
        ps.setVdd(value)

    @staticmethod
    def getVdd_PMBusValue(board, provider, psId) -> int:
        ps = PS._getPSElement(board, psId)
        ps.setProvider(provider)
        return ps.readVdd()

    @staticmethod
    def getIdd_PMBusValue(board, provider, psId) -> float:
        ps = PS._getPSElement(board, psId)
        ps.setProvider(provider)
        return ps.readIdd()

    @staticmethod
    def setPLLVoltageControl(board, provider, psId, value: float):
        ps = PS._getPSElement(board, psId)
        if ps.vc is None:
            raise Exception('PS has no Voltage Control element')
        if not ps.vc.isVoltageInValidRange(value):
            raise Exception('Vdd value you are trying to set is out of valid range for current PS')
        ps.setProvider(provider)
        ps.setPll(value)

    @staticmethod
    def getTemp_DC2DC_PMBusValue(board, provider, psId) -> float:
        ps = PS._getPSElement(board, psId)
        ps.setProvider(provider)
        return ps.readTemperature()

    @staticmethod
    def storeVddToNVM(board, provider, psId, factoryDeafult=False) -> float:
        if not factoryDeafult:
            ps = PS._getPSElement(board, psId)
            ps.setProvider(provider)
            return ps.store_Vdd_to_NVM()

        else:  # If factory default = Trueïƒ¨	Ignore PS_ID field. Use the xml VNOM value and store it to Vboot of ALL
            # power supplies on the board.
            pss = PS._getPSsElements(board)
            for ps in pss:
                try:
                    ps.setProvider(provider)
                    ps.setVdd(ps.vnom_factory_default)
                    ps.store_Vdd_to_NVM()

                except Exception as e:
                    pass

    """*********************************************************************************
    Board PS search APIs
    *********************************************************************************"""

    @staticmethod
    def _getPSsElements(board) -> List[PS]:
        return board.getItemElementsByType(ItemTypeEnum.PS)

    @staticmethod
    def _getPSElement(board, psId) -> PS:
        return board.getItemElementById(ItemTypeEnum.PS, psId)

    def _debug_read_back(self, stage, slaveAddr, regAddr, nbytes, expected_data):
        if not self._debug:
            return
        data_back = self.ReadArrayPMBus(self.addr, regAddr, nbytes)
        print(
            f"[Read Back] stage:{stage}, addr:{hex(slaveAddr)},reg:{hex(regAddr)}, try to write:{hex(expected_data)}, read back:{hex(data_back)}")

    """*********************************************************************************
    Getters
    *********************************************************************************"""

    def getInfo(self) -> dict:
        try:
            self.def_vol = self.getvNom_runtime()
        except Exception as e:
            pass
        res = {
            'name': self.desc,
            'measureType': self.measure_type,
            'minVol': self.min_vol,
            'maxVol': self.max_vol,
            'address': self.addr,
            'defVol': self.def_vol,
            'vNomFactoryDefault': self.vnom_factory_default
        }
        return res

    def getPSType(self) -> int:
        if self.type_.startswith("TPS"):
            return PSTypeEnum.TI
        else:
            return PSTypeEnum.Ericsson

    def getTPSInfo(self) -> [int, int, int]:
        if self.getPSType() == PSTypeEnum.TI:
            tpsType = self.getTPSType()
            page = self.getPage()
            subChannel = self.getSubChannel()
            return tpsType, page, subChannel

        else:
            raise Exception('Invalid TPS type')

    def getSubChannel(self) -> int:
        subChannel = -1
        match = re.search(r'_(\d)$', self.type_)
        if match is not None:
            subChannel = int(match[1])
        return subChannel

    def getTPSType(self) -> int:
        if self.type_.startswith("TPS536C"):
            tpsType = TPSTypeEnum.TPS536cx
        elif self.type_.startswith("TPS5368"):
            tpsType = TPSTypeEnum.TPS5368x
        elif self.type_.startswith("TPS65400"):
            tpsType = TPSTypeEnum.TPS65400
        else:
            raise Exception(f"Type {self.type_} not supported")
        return tpsType

    def getPage(self) -> int:
        page = 0x0
        match = re.search(r'_(All|[A-D])', self.type_)
        if match is not None:
            if match[1] == 'A':
                page = TIChannelEnum.ChannelA
            elif match[1] == 'B':
                page = TIChannelEnum.ChannelB
            elif match[1] == 'C':
                page = TIChannelEnum.ChannelC
            elif match[1] == 'D':
                page = TIChannelEnum.ChannelD
            elif match[1] == 'All':
                page = TIChannelEnum.ChannelAll
        else:
            page = TIChannelEnum.NA
        return page

    """*********************************************************************************
    Getters For Calculated values and Validators
    *********************************************************************************"""

    def getTPSCode(self, value: float) -> int:
        if self.getTPSType() == TPSTypeEnum.TPS5368x:  # VId
            # see table in TI_tps53681.pdf page 38
            if value == 0:
                return 0
            divider = self.getSubChannel()
            if divider != -1:  # if we have sub_channel, should be used as a divider, for Hawk
                value = int(value / (divider * 2))
            return int((((value / 1000.0) - 0.25) / 0.005) + 1)
        elif self.getTPSType() == TPSTypeEnum.TPS536cx:  # Linear
            return int((value / 1000.0) / pow(2.0, -10))

    def getvNom_runtime(self):
        try:
            self.setTiChannel()

            tpsType, page, subChannel = self.getTPSInfo()
            if tpsType == TPSTypeEnum.TPS65400:
                return self.Calculate_TPS65400_VddFormula()

            data = self.ReadArrayPMBus(self.addr, 0x21, 2)
            if tpsType == TPSTypeEnum.TPS5368x:
                return PS.Calculate_TPS5368x_VddFormula(data, subChannel)
            elif tpsType == TPSTypeEnum.TPS536cx:
                return PS.Calculate_TPS536cx_VddFormula(data)
            return self.vnom_factory_default
        except:  # if unexpected error occure -> return the default as it defined in xml
            return self.vnom_factory_default

    def getMarginSelection(self, value: float, run_time=False) -> int:

        if run_time:
            self.def_vol = self.getvNom_runtime()  # if failed to resolve vnom at run time for some reason -> use xml

        if value == self.def_vol:
            return MarginSelectionEnum.NOMINAL.numerator
        elif self.min_vol <= value < self.def_vol:
            return MarginSelectionEnum.LOW.numerator
        elif self.def_vol < value <= self.max_vol:
            return MarginSelectionEnum.HIGH.numerator
        else:
            raise Exception("Error in getMarginSelection")

    def isVddInValidRange(self, value: float) -> bool:
        if self.min_vol <= value <= self.max_vol:
            return True
        return False

    @staticmethod
    def CalculateCurrentFormula(data: int) -> float:
        Y = TwosComplement(11, data & 0x7FF)
        N = TwosComplement(5, (data & 0xF800) >> 11)
        A = Y * pow(2.0, N)
        return A

    def isPowerSupplySupportChannel(self):
        tpsType = self.getTPSType()
        page = self.getPage()
        if ((tpsType == TPSTypeEnum.TPS5368x or tpsType == TPSTypeEnum.TPS536cx) and
            (page.numerator in range(TIChannelEnum.ChannelB.numerator + 1))) or \
                (tpsType == TPSTypeEnum.TPS65400 and
                 (page.numerator in range(TIChannelEnum.ChannelD.numerator + 1) or
                  page == TIChannelEnum.ChannelAll.numerator)):
            return True
        return False

    @staticmethod
    def CalculateDC2DCTempFormula_SLINEAR11(data: int) -> float:
        N = TwosComplement(5, (data & 0xF800) >> 11)  # exponent
        M = TwosComplement(11, data & 0x7FF)  # mantissa
        D = M * pow(2.0, N)
        return D

    @staticmethod
    def Calculate_TPS5368x_VddFormula(data: int, subChannel):  # mV
        vddVal = (data * 5) + 245
        vddVal = 0 if vddVal <= 245 else vddVal

        if subChannel != -1:
            vddVal = vddVal * (subChannel * 2)
        return vddVal

    @staticmethod
    def Calculate_TPS536cx_VddFormula(data: int):  # mV
        value = (2 ** -10) * data
        return round(value * 1000)  # mV

    def Calculate_TPS65400_VddFormula(self):
        def_vol = self.def_vol
        def_vref = self.def_vref
        x = def_vol / def_vref
        data = self.ReadArrayPMBus(self.addr, 0xd8, 1)
        # according to D8h VREF_COMMAND TABLE  from : 00000000 is 0.60v to 11111111 is 1.87 v (bit resolution of 10mV)
        value_v = (data * 0.01) + 0.60

        vdd = value_v * x
        return round(vdd * 1000)

    """*********************************************************************************
    PS Algo
    *********************************************************************************"""

    def setVdd(self, value: float):

        write_operation_last = True
        dataToWrite = 0

        if self.getPSType() == PSTypeEnum.TI:
            if self.getTPSType() == TPSTypeEnum.TPS65400:
                readData = self.ReadArrayPMBus(self.addr, 0x10, 1)  # self.ReadArrayPMBus(self.addr << 1, 0x10, 1)
                if readData == 0x40:
                    self.getProvider().genericWrite(self.addr << 1, 1, 0x0, 1, 0xff)
                    self.getProvider().genericWrite(self.addr << 1, 1, 0x10, 1, 0x20)
                self.setTiChannel()
                return self.SetVdd_TPS65400(value)

            elif self.getTPSType() == TPSTypeEnum.TPS5368x or self.getTPSType() == TPSTypeEnum.TPS536cx:
                self.setTiChannel()
                dataToWrite = self.getTPSCode(value)
                if self.getTPSType() == TPSTypeEnum.TPS536cx:
                    write_operation_last = False
            else:
                raise Exception("TPS type calc not found :" + self.type_)
        else:  # self.getPSType() == PSTypeEnum.Ericsson
            # 2^-13 = 0.00012207
            dataToWrite = int((value / 1000.0) / 0.00012207 + 0.5)

        self.getProvider().genericWrite(self.addr << 1, 1, 0x01, 1, 0x80)

        self._debug_read_back("set_vdd_0", self.addr, 0x01, 1, 0x80)

        marginSelection = self.getMarginSelection(value, run_time=True)
        if marginSelection == MarginSelectionEnum.HIGH:
            regAddr = 0x25
            marginValue = 0xa4
        elif marginSelection == MarginSelectionEnum.LOW:
            regAddr = 0x26
            marginValue = 0x98
        elif marginSelection == MarginSelectionEnum.NOMINAL:
            return GT_OK
        else:
            raise Exception("Margin Selection out of range")

        sleep(2)  # sleep between nominal and high/low

        if not write_operation_last:
            # change the operation in the master
            # print("change the operation in the master")
            self.getProvider().genericWrite(self.addr << 1, 1, 0x01, 1, marginValue)

            self._debug_read_back("set_vdd_0", self.addr, 0x01, 1, marginValue)

        # write vdd to master
        # print("write vdd to master")
        self.getProvider().genericWrite(self.addr << 1, 1, regAddr, 2, dataToWrite)

        self._debug_read_back("VOUT", self.addr, regAddr, 2, dataToWrite)

        sleep(2)  # sleep between VOUT and VBOOT

        # Write vdd to VBOOT register (0xDB) for TPS53681 only
        if self.getPSType() == PSTypeEnum.TI and self.getTPSType() == TPSTypeEnum.TPS5368x:
            # print("Write vdd to VBOOT register (0xDB) for TPS53681 only")
            self.getProvider().genericWrite(self.addr << 1, 1, 0xDB, 1, dataToWrite)

            self._debug_read_back("VBOOT", self.addr, 0xDB, 1, dataToWrite)

        # write vdd to slaves
        for slave in self.slaveAddr:
            self.getProvider().genericWrite(slave << 1, 1, regAddr, 2, dataToWrite)

        if write_operation_last:
            # print("change the operation in the master")
            # change the operation in the master
            self.getProvider().genericWrite(self.addr << 1, 1, 0x01, 1, marginValue)

            self._debug_read_back("write_operation_last", self.addr, 0x01, 1, marginValue)

    def readVdd(self) -> int:
        tpsType = None
        if self.getPSType() == PSTypeEnum.TI:
            tpsType, page, subChannel = self.getTPSInfo()
            if tpsType == TPSTypeEnum.TPS5368x:
                self.setTiChannel()
                data = self.ReadArrayPMBus(self.addr, 0x8b, 2)

                vddVal = PS.Calculate_TPS5368x_VddFormula(data, subChannel)
                return vddVal
            if tpsType == TPSTypeEnum.TPS536cx:
                # VOUT_MODE =16h -> Exponent = 10110b -> two's complement -> -10
                # value= 2^componeen * data -> 2^-10

                self.setTiChannel()
                data = self.ReadArrayPMBus(self.addr, 0x8b, 2)

                return PS.Calculate_TPS536cx_VddFormula(data)
        # else:   # self.getPSType() == PSTypeEnum.Ericsson
        raise Exception(
            "PS {0} not supported. support TPS5368x/TPS536cx power supplies only.".format(str(tpsType.name)))

    def readIdd(self) -> float:
        tpsType, page, subChannel = self.getTPSInfo()
        if tpsType != TPSTypeEnum.TPS5368x and tpsType != TPSTypeEnum.TPS536cx:
            raise Exception(
                "PS {0} not supported. support TPS5368x and TPS536cx power supplies only.".format(str(tpsType)))

        if self.getPSType() == PSTypeEnum.TI:
            self.setTiChannel()
            self.getProvider().genericWrite(self.addr << 1, 1, 0x4, 1, 0x80)

        data = self.ReadArrayPMBus(self.addr, 0x8c, 2)
        # calculate Current
        totalCurrent = self.CalculateCurrentFormula(data)

        # Read Current from slaves
        for i in range(len(self.slaveAddr)):
            data = self.ReadArrayPMBus(self.slaveAddr[i], 0x8c, 2)
            totalCurrent += self.CalculateCurrentFormula(data)

        return totalCurrent * self.phase_multiplier

    def setPll(self, value: float):
        # TODO: check if necessary
        pass

    def readTemperature(self) -> float:
        tpsType, page, subChannel = self.getTPSInfo()
        if tpsType != TPSTypeEnum.TPS5368x and tpsType != TPSTypeEnum.TPS536cx:
            raise Exception(
                "PS {0} not supported. support TPS5368x and TPS536cx power supplies only.".format(str(tpsType.name)))

        if tpsType != TPSTypeEnum.TPS536cx:
            pass

        if self.getPSType() == PSTypeEnum.TI:
            self.setTiChannel()
            # self.getProvider().genericWrite(self.addr << 1, 1, 0x4, 1, 0x80)

        data = self.ReadArrayPMBus(self.addr, 0x8D, 2)
        # calculate Current
        value = self.CalculateDC2DCTempFormula_SLINEAR11(data)
        return value

    def store_Vdd_to_NVM(self):

        def store_to_nvm_TPS536xx(VOUT_COMMAND, NVM_REG, VBOOT=None):
            # addr = self.addr << 1
            # Read OPERATION register (0x1)
            op = self.ReadArrayPMBus(self.addr, 0x1, 1)

            if op == 0x0 or op == 0x80:
                # No updated is needed. Default power up value is set to VOUT_COMMAND  and VBOOT  (for TPS5368x)
                return

            if op == 0xa4 or op == 0xa8:
                # 	Read MARGIN_HIGH(0x25) register and write its value to VOUT_COMMAND and VBOOT  (for TPS5368x)
                margin = self.ReadArrayPMBus(self.addr, 0x25, 2)

            elif op == 0x94 or op == 0x98:
                # 	Read MARGIN_LOW(0x26) register and write its value to VOUT_COMMAND  and VBOOT  (for TPS5368x)
                margin = self.ReadArrayPMBus(self.addr, 0x26, 2)
            else:
                return

            # write margin (high/low) value to VOUT_COMMAND  and VBOOT  (for TPS5368x)
            if VBOOT is not None:
                self.getProvider().genericWrite(self.addr << 1, 1, VBOOT, 1, margin)
            self.getProvider().genericWrite(self.addr << 1, 1, VOUT_COMMAND, 2, margin)
            # Store to NVM: Write to register NVM_REG (no value is needed)
            self.getProvider().genericWrite(self.addr << 1, 0, NVM_REG, 1, NVM_REG)
            # self.getProvider().genericWrite(self.addr << 1, 0, NVM_REG, 1, NVM_REG)

        # read vdd from active
        tpsType, page, subChannel = self.getTPSInfo()

        if tpsType == TPSTypeEnum.TPS65400:
            # Clear write protect : Write 0x00 to register 0x10
            self.getProvider().genericWrite(self.addr << 1, 1, 0x10, 1, 0x0)
            # Store to NVM : Write to register 0x11 (no value is needed)
            self.getProvider().genericWrite(self.addr << 1, 0, 0x11, 1, 0x11)

        elif tpsType == TPSTypeEnum.TPS536cx:
            store_to_nvm_TPS536xx(0x21, 0x15)
        elif tpsType == TPSTypeEnum.TPS5368x:
            store_to_nvm_TPS536xx(0x21, 0x11, 0xdb)

    """*********************************************************************************
    Auxiliary methods
    *********************************************************************************"""

    def setTiChannel(self):
        if not self.isPowerSupplySupportChannel():
            raise Exception('Channel not supported in selected PS')
        self.getProvider().genericWrite(self.addr << 1, 1, 0x0, 1, self.getPage().numerator)

        sleep(0.1)
        self._debug_read_back("setTiChannel", self.addr, 0x0, 1, self.getPage().numerator)

    def SetVdd_TPS65400(self, value: float):
        vRef = (value / self.def_vol) * (
                self.def_vref / 1000)  # Vout = Vref * Vnominal (from xml file)/0.8 -> now instead of 0.8 is def_vref/100
        vRefCommand = round((vRef - 0.6) * 100)

        self.getProvider().genericWrite(self.addr << 1, 1, 0xd8, 1, vRefCommand)

        self._debug_read_back("SetVdd_TPS65400", self.addr, 0xd8, 1, vRefCommand)

    """*********************************************************************************
    IO Methods
    *********************************************************************************"""

    def ReadArrayPMBus(self, addr: int, regAddr: int, nBytes: int) -> int:
        data = self.getProvider().ReadI2CArray(addr << 1, nBytes, regAddr, 1)
        val = 0
        for i in range(len(data)):
            val += data[i] << (i * 8)
        return val


"""*********************************************************************************
PS related ENUMS
*********************************************************************************"""


class PSTypeEnum(IntEnum):
    Ericsson = 0,
    TI = 1


class TPSTypeEnum(IntEnum):
    TPS536cx = 0,  # 12 phases
    TPS5368x = 1,  # 8 phases
    TPS65400 = 2


class TIChannelEnum(IntEnum):
    ChannelA = 0x0,
    ChannelB = 0x1,
    ChannelC = 0x2,
    ChannelD = 0x3,
    ChannelAll = 0xff,
    NA = 0x0


class MarginSelectionEnum(IntEnum):
    HIGH = 0,
    LOW = 1,
    NOMINAL = 2
