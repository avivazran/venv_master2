# from __future__ import annotations
from time import sleep

from Marvell.EMClientPy.src.ElectricalManagmentModels.Base_Models import *
from Marvell.EMClientPy.src.ElectricalManagmentModels.Model_Enums import IOFuncTypeEnum, PolarityTypeEnum
from Marvell.EMClientPy.src.Common.Types import BoardPowerModeEnum
from typing import List

class IO:
    pass
class IO(ItemType):
    bit = None

    def __init__(self, elm, connId):
        super(IO, self).__init__(elm, None, connId, ItemTypeEnum.IO)
        self.setOpenConnId(0)
        if elm is not None:
            bits = self.getChildrenElements("bit", 16)
            self.bit = []
            for b in bits:
                self.bit.append(IoBitType(b, self, 0))

    """*********************************************************************************
    Board IO search APIs
    *********************************************************************************"""
    @staticmethod
    def _getIOsElements(board) -> List[IO]:
        return board.getItemElementsByType(ItemTypeEnum.IO)

    @staticmethod
    def _getIOElement(board, ioId) -> IO:
        return board.getItemElementById(ItemTypeEnum.A2D, ioId)

    """*********************************************************************************
    Getters
    *********************************************************************************"""
    def _getFuncBit(self, funcName: IOFuncTypeEnum):
        for b in self.bit:
            if b.func == funcName.name:
                return b
        raise Exception('No info for' + funcName.name + 'in xml')

    def getFuncError(self):
        return self._getFuncBit(IOFuncTypeEnum.FuncError)

    def getBoardReset(self):
        return self._getFuncBit(IOFuncTypeEnum.BoardReset)

    def getDutPwr(self):
        return self._getFuncBit(IOFuncTypeEnum.DutPwr)

    def getBoardPwr(self):
        return self._getFuncBit(IOFuncTypeEnum.BoardPwr)

    def getGePhyReset(self):
        return self._getFuncBit(IOFuncTypeEnum.GePhyReset)

    def getResetDUT(self):
        return self._getFuncBit(IOFuncTypeEnum.ResetDUT)

    def getBoardPowerStatus(self):
        return self._getFuncBit(IOFuncTypeEnum.BoardPowerStatus)

    def getStartControl(self):
        return self._getFuncBit(IOFuncTypeEnum.StartControl)

    def getRdyStatus(self):
        return self._getFuncBit(IOFuncTypeEnum.RdyStatus)

    def getFanPwr(self):
        return self._getFuncBit(IOFuncTypeEnum.FanPwr)

    def getSetVoltageControl(self):
        return self._getFuncBit(IOFuncTypeEnum.SetVoltageControl)

    """*********************************************************************************
    IO Algo
    *********************************************************************************"""
    @staticmethod
    def dutPwr(board, provider, action: BoardPowerModeEnum):
        io = IO._getIOsElements(board)[0]
        io.setProvider(provider)
        board.setPath(provider, io)
        io.setDutPowerState(action)

    @staticmethod
    def boardReset(board, provider, delay: int):
        io = IO._getIOsElements(board)[0]
        io.setProvider(provider)
        board.setPath(provider, io)
        io.resetBoard(delay)

    @staticmethod
    def boardPwr(board, provider, action: BoardPowerModeEnum):
        io = IO._getIOsElements(board)[0]
        io.setProvider(provider)
        boardPwrBit = io.getBoardPwr()
        board.setPath(provider, boardPwrBit)
        io.setBoardPowerState(action)

    """*********************************************************************************
    IO Algo
    *********************************************************************************"""
    def setDutPowerState(self, action: BoardPowerModeEnum):
        dutPwrBit = self.getDutPwr()
        self.setPowerMode(dutPwrBit, action)

    def resetBoard(self, delay: int = 100):
        boardResetBit = self.getBoardReset()
        pin = boardResetBit.num
        if delay < 100:
            raise Exception('Reset should be more than 100ms')

        doReset = True if boardResetBit.polarity == PolarityTypeEnum.REGULAR else False
        # Do reset
        self.setReset(doReset, pin)
        # wait delay time
        sleep(delay / 1000)
        self.setReset(not doReset, pin)

    def setBoardPowerState(self, action: BoardPowerModeEnum):
        boardPwrBit = self.getBoardPwr()
        self.setPowerMode(boardPwrBit, action)


    """*********************************************************************************
    Auxiliary methods
    *********************************************************************************"""
    def getIOInputState(self):
        data = self.getProvider().ReadArray(self.addr, 0x6, 2)
        state = data[0] | (data[1] << 8)
        return state

    def setIOInputState(self, state: int):
        byte_0 = state & 0xff
        byte_1 = (state >> 8) & 0xff
        data = bytes([byte_0, byte_1])
        self.getProvider().WriteArray(self.addr, 0x6, 2, data)

    def setReset(self, enable: bool, bit: int):
        # Set the port to output
        data = self.getIOInputState()
        # change bit to be output
        data = data & ~(1 << bit)
        self.setIOInputState(data)
        # read register
        data = self.getProvider().ReadArray(self.addr, 0x2, 2)

        byte_0 = data[0]
        byte_1 = data[1]

        if bit < 8:
            if enable:
                # clear bit
                byte_0 &= ~ (1 << bit % 8)
            else:
                # set bit
                byte_0 |= (1 << bit % 8)
        elif 8 <= bit < 16:
            if enable:
                # clear bit
                byte_1 &= ~ (1 << bit % 8)
            else:
                # set bit
                byte_1 |= (1 << bit % 8)

        valueToWrite = bytes([byte_0, byte_1])
        self.getProvider().WriteArray(self.addr, 0x2, 2, valueToWrite)

    def setPowerMode(self, ioBit, mode: BoardPowerModeEnum):
        pin = ioBit.num
        polarity = ioBit.polarity

        state = self.getIOInputState()
        if mode == BoardPowerModeEnum.POWER_LOCAL:
            state |= 1 << pin
            self.setIOInputState(state)
        else:
            state &= ~(1 << pin)
            self.setIOInputState(state)

            # read register
            value: bytes = self.getProvider().ReadArray(self.addr, 0x2, 2)
            byte_0 = value[0]
            byte_1 = value[1]
            if (mode.name == BoardPowerModeEnum.POWER_ON.name and polarity.name == PolarityTypeEnum.REGULAR.name) or \
                    (mode.name == BoardPowerModeEnum.POWER_OFF.name and polarity.name == PolarityTypeEnum.INVERSE.name):
                # Set bit
                if pin < 8:     # pin / 8 == 0
                    byte_0 = byte_0 | (1 << (pin % 8))
                elif 8 <= pin < 16:     # pin / 8 == 1
                    byte_1 = byte_1 | (1 << (pin % 8))
            elif (mode.name == BoardPowerModeEnum.POWER_ON.name and polarity.name == PolarityTypeEnum.INVERSE.name) or \
                    (mode.name == BoardPowerModeEnum.POWER_OFF.name and polarity.name == PolarityTypeEnum.REGULAR.name):
                # Clear bit
                if pin < 8:     # pin / 8 == 0
                    byte_0 = byte_0 & ~ (1 << pin % 8)
                elif 8 <= pin < 16:     # pin / 8 == 1
                    byte_1 = byte_1 & ~ (1 << pin % 8)

            valueToWrite: bytes = bytes([byte_0, byte_1])

            # Write the data to the IO.
            self.getProvider().WriteArray(self.addr, 0x2, 2, valueToWrite)

class IoBitType:
    pass

class IoBitType(EmModel):
    func = None
    polarity = None
    smm_id = 0
    voltage_id = 0
    bit_value_0 = 0
    bit_value_1 = 0
    num = 0

    def __init__(self, elm, parent, connId):
        super(IoBitType, self).__init__(elm, parent, connId)
        if elm is not None:
            self.func = Models_Validator.funcType(self.getFirstChildElement('func'))
            self.polarity = Models_Validator.polarityType(self.getFirstChildElement('polarity'), self.func)
            self.smm_id = Models_Validator.nonNegativeInteger(self.getFirstChildElement('smm_id'))
            self.voltage_id = Models_Validator.nonNegativeInteger(self.getFirstChildElement('voltage_id'))
            self.bit_value_0 = Models_Validator.nonNegativeInteger(self.getFirstChildElement('bit_value_0'))
            self.bit_value_1 = Models_Validator.nonNegativeInteger(self.getFirstChildElement('bit_value_1'))
            self.num = Models_Validator.nonNegativeInteger(self.getAttribute('num'), 15)


# class IoBitNoSmmType(EmModel):
#     func = None
#     polarity = None
#
#     def __init__(self, elm):
#         super(IoBitNoSmmType, self).__init__(elm)
#         if elm is not None:
#             self.func = Models_Validator.funcNoSmmType(self.getFirstChildElement('func'))
#             self.polarity = Models_Validator.polarityType(self.getFirstChildElement('polarity'))
#
#
# class IoBitSmmType(EmModel):
#     function = None
#     polarity = None
#     smm_id = 0
#
#     def __init__(self, elm):
#         super(IoBitSmmType, self).__init__(elm)
#         if elm is not None:
#             self.func = Models_Validator.funcSmmType(self.getFirstChildElement('function'))
#             self.polarity = Models_Validator.polarityType(self.getFirstChildElement('polarity'))
#             self.smm_id = Models_Validator.nonNegativeInteger(self.getFirstChildElement('smm_id'))


