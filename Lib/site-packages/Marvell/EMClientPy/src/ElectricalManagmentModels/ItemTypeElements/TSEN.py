# from __future__ import annotations
from enum import Enum

from Marvell.EMClientPy.src.ElectricalManagmentModels.Base_Models import EmModel, VrefElement
from Marvell.EMClientPy.src.ElectricalManagmentModels.Models_Validator import Models_Validator
from Marvell.EMClientPy.src.ElectricalManagmentModels.Model_Enums import ItemTypeEnum
from Marvell.EMClientPy.src.Common.Utilities import celsiusToKelvin, kelvinToCelsius
from typing import List
class TSEN:
    pass

class TSEN_Ch:
    pass

class TSEN(VrefElement):
    type_ = None
    mode = None
    OT = 0
    ch = None

    def __init__(self, elm, parent, connId):
        super(TSEN, self).__init__(elm, parent, connId, ItemTypeEnum.TSEN)
        if elm is not None:
            type_ = Models_Validator.pattern(r'[mM][aA][xX]\d{1,4}', self.getFirstChildElement('type'))
            if type_ == TSENTypeEnum.MAX6695.value:
                self.type_ = TSENTypeEnum.MAX6695
            else:
                self.type_ = TSENTypeEnum.NOT_SUPPORTED_TYPE
            mode = Models_Validator.pattern(r'regular', self.getFirstChildElement('mode'))
            if mode == TSENModeEnum.REGULAR.value:
                self.mode = TSENModeEnum.REGULAR
            else:
                self.mode = TSENModeEnum.NOT_SUPPORTED_MODE
            self.OT = Models_Validator.nonNegativeInteger(self.getFirstChildElement('OT'))
            ch = self.getChildrenElements('ch', 12)
            self.ch = []
            for c in ch:
                self.ch.append(TSEN_Ch(c, self, 0))

    """*********************************************************************************
    TSEN EM APIs
    *********************************************************************************"""
    @staticmethod
    def getTemperature(board, provider, tsenId, tsenCh):
        tsen: TSEN = TSEN._getTSENElement(board, tsenId)
        tsen.setProvider(provider)
        temp = tsen.readTemp(board, tsenCh)
        return temp

    """*********************************************************************************
    Board TSEN search APIs
    *********************************************************************************"""
    @staticmethod
    def _getTSENsElements(board) -> List[TSEN]:
        return board.getItemElementsByType(ItemTypeEnum.TSEN)

    @staticmethod
    def _getTSENElement(board, tsenId) -> TSEN:
        return board.getItemElementById(ItemTypeEnum.TSEN, tsenId)

    """*********************************************************************************
    Getters
    *********************************************************************************"""
    def GetChannel(self, channelNumber):
        for c in self.ch:
            if c.num == channelNumber:
                return c
        return None

    def getChannelNumbers(self) -> List[int]:
        res: List[int] = []
        for ch in self.ch:
            res.append(ch.num)
        return res

    """*********************************************************************************
    TSEN Algo
    *********************************************************************************"""
    def readTemp(self, board, chNum):
        ch = self.GetChannel(chNum)
        if ch is None:
            raise Exception(f"Channel num={chNum} not found.")
        else:
            board.setPath(self.getProvider(), self)
        try:
            #  Execute the logic
            if self.type_.name == TSENTypeEnum.MAX6695.name and self.mode.name == TSENModeEnum.REGULAR.name:
                temp = self.readTempMAX6695(ch)
                return temp
        except Exception as e:
            raise e

    """*********************************************************************************
    Auxiliary methods
    *********************************************************************************"""
    def readTempMAX6695(self, ch: TSEN_Ch):
        chNum = ch.num
        if chNum not in range(0, 3):
            raise Exception('Channel out of range.')

        reg = 0x1 if chNum != 2 else 0x0
        defaultValue = 0x20 if chNum != 1 else 0x28

        self.getProvider().genericWrite(self.addr << 1, 1, 0x9, 1, defaultValue)
        data = self.ReadArrayPMBus(self.addr, reg, 1)

        if data != 0x80:
            if (data & 0x80) == 0x80:   # value < 0
                data = ~data + 1
                value = -1 * int(data & 0xff)
            else:
                value = data

            if chNum != 2 and ch.ideal_factor is not None:  # ideal_factor is not applicable to channel 2
                value = kelvinToCelsius(celsiusToKelvin(value) * 1.008 / ch.ideal_factor)

            return value

    """*********************************************************************************
    IO Methods
    *********************************************************************************"""
    def ReadArrayPMBus(self, addr: int, regAddr: int, nBytes: int) -> int:
        data = self.getProvider().ReadI2CArray(addr << 1, nBytes, regAddr, 1)
        val = 0
        for i in range(len(data)):
            val += data[i] << (i * 8)
        return val

class TSEN_Ch:
    pass

class TSEN_Ch(EmModel):
    valid = None
    name = ''
    offset = 0
    num = 0
    ideal_factor: float = 1.008

    def __init__(self, elm, parent, connId):
        super(TSEN_Ch, self).__init__(elm, parent, connId)
        if elm is not None:
            self.valid = Models_Validator.validType(self.getFirstChildElement('valid'))
            self.name = self.getFirstChildElement('name')
            self.offset = Models_Validator.nonNegativeInteger(self.getFirstChildElement('offset'))
            self.num = Models_Validator.nonNegativeInteger(self.getAttribute('num'), 11)
            self.ideal_factor = Models_Validator.float(self.getFirstChildElement('ideal_factor'))


class TSENTypeEnum(Enum):
    NOT_SUPPORTED_TYPE = None
    MAX6695 = 'MAX6695'


class TSENModeEnum(Enum):
    NOT_SUPPORTED_MODE = None
    REGULAR = 'regular'
