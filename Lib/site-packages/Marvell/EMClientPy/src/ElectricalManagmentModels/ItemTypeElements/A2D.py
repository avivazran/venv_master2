# from __future__ import annotations
from Marvell.EMClientPy.src.ElectricalManagmentModels.Base_Models import VrefElement, EmModel
from Marvell.EMClientPy.src.ElectricalManagmentModels.Model_Enums import ItemTypeEnum, PolarityEnum, ModeEnum
from Marvell.EMClientPy.src.ElectricalManagmentModels.Models_Validator import Models_Validator
from Marvell.EMClientPy.src.Common.Constants import *
from Marvell.EMClientPy.src.Common.Types import *
from Marvell.EMClientPy.src.Common.Utilities import TwosComplement
from typing import List
class A2D_Ch:
    pass

class A2D:
    pass

class A2D(VrefElement):
    type = ''
    mode = None
    polarity = None
    ch: List[A2D_Ch] = None

    def __init__(self, elm, parent, connId):
        super(A2D, self).__init__(elm, parent, connId, ItemTypeEnum.A2D)
        if elm is not None:
            self.type = self.getFirstChildElement('type')
            mode = Models_Validator.pattern(r'(?:single_ended|differential)', self.getFirstChildElement('mode'))
            self.mode = A2D._modeCast(mode)
            polarity = Models_Validator.pattern(r'(?:bi|uni)polar', self.getFirstChildElement('polarity'))
            self.polarity = A2D._polarityCast(polarity)
            ch = self.getChildrenElements('ch', 12)
            self.ch = []
            for c in ch:
                self.ch.append(A2D_Ch(c, self, 0))

    """*********************************************************************************
    A2D EM APIs
    *********************************************************************************"""
    @staticmethod
    def getA2DsIDs(board) -> List[int]:
        res: List[int] = []
        for a2d in A2D._getA2DsElements(board):
            res.append(a2d.id)
        return res

    @staticmethod
    def getA2DChannelsNumbers(board, a2dId) -> List[int]:
        a2d = A2D._getA2DElement(board, a2dId)
        return a2d.getChannelNumbers()

    @staticmethod
    def readA2DValue(board, provider, a2dId, a2dCh):
        a2d = A2D._getA2DElement(board, a2dId)
        a2d.setProvider(provider)
        return a2d.read(board, a2dCh)

    """*********************************************************************************
    Board A2D search APIs
    *********************************************************************************"""
    @staticmethod
    def _getA2DsElements(board) -> List[A2D]:
        return board.getItemElementsByType(ItemTypeEnum.A2D)

    @staticmethod
    def _getA2DElement(board, a2dId) -> A2D:
        return board.getItemElementById(ItemTypeEnum.A2D, a2dId)

    """*********************************************************************************
    Getters
    *********************************************************************************"""
    def GetResolution(self):
        typeMap = {
            'MAX1139': 10,
            'MAX1239': 12,
        }
        res = typeMap[self.type]
        return res if res is not None else -1

    def GetChannel(self, channelNumber):
        for c in self.ch:
            if c.num == channelNumber:
                return c
        return None

    def getChannelNumbers(self) -> List[int]:
        res: List[int] = []
        for ch in self.ch:
            res.append(ch.num)
        return res

    """*********************************************************************************
    Getters For Calculated values and Validators
    *********************************************************************************"""
    def convertToRawValue(self, value: int):
        result = ((1 << self.GetResolution()) - 1) & value
        return result

    def resolvePolarity(self):
        polarity = PolarityEnum.UNIPOLAR
        if self.mode == ModeEnum.DIFFERENTIAL and self.polarity == PolarityEnum.BIPOLAR:
            polarity = PolarityEnum.BIPOLAR
        return polarity

    @staticmethod
    def _modeCast(text: str):
        if text == 'single_ended':
            return ModeEnum.SINGLE_ENDED
        elif text == 'differential':
            return ModeEnum.DIFFERENTIAL
        else:
            return text

    @staticmethod
    def _polarityCast(text: str):
        if text == 'bipolar':
            return PolarityEnum.BIPOLAR
        elif text == 'unipolar':
            return PolarityEnum.UNIPOLAR
        else:
            return text

    def CalculateFormula(self, channel: A2D_Ch, data):
        if channel.valid:
            mask = 0x3FF
            if self.GetResolution() == 12:
                mask = 0xFFF
            retVal = (data & mask) * self.vref_vol * channel.mult  # * 1000
            retVal /= ((0x1 << self.GetResolution()) * channel.div)

            if self.resolvePolarity() == PolarityEnum.BIPOLAR:
                retVal /= 2

            retVal += channel.offset * 1000

            if str(channel.measureType).startswith('m'):
                retVal = round(retVal * 1000)

            return retVal
        return 0

    """*********************************************************************************
    A2D Algo
    *********************************************************************************"""
    def read(self, board, chNum):
        ch = self.GetChannel(chNum)
        if ch is not None:
            board.setPath(self.getProvider(), self)
        try:
            #  Execute the logic
            res = ch.getInfo()
            data = self.readValue(ch)
            res['value'] = self.CalculateFormula(ch, data)
            res['rawValue'] = self.convertToRawValue(data)
            return res
        except Exception as e:
            raise e

    """*********************************************************************************
    Auxiliary methods
    *********************************************************************************"""
    def readValue(self, channel: A2D_Ch):
        bits = self.GetResolution()
        data = self.ReadCode(channel)
        if self.resolvePolarity() == PolarityEnum.BIPOLAR:
            data = TwosComplement(bits, data)
        return data

    def ReadCode(self, channel):
        clk = 0
        reset = 1

        nBytes = int(self.GetResolution() / 8 + (1 if self.GetResolution() % 8 != 0 else 0))
        if nBytes > 4:
            return GT_FAIL

        # Write to Setup register
        reg = 0x1
        sel = 0x2 if self.vref == VrefEnum.EXTERNAL else 0x5
        polarity = 0 if self.polarity == PolarityEnum.UNIPOLAR else 1

        data = (reg << 7) | (sel << 4) | (clk << 3) | (polarity << 2) | (reset << 1)
        bytesWritten = self.getProvider().WriteByte(self.addr, data)
        if bytesWritten != 1:
            return GT_FAIL

        # Write to Config register
        reg = 0x0
        scan = 0x3
        channelNum = channel.num & 0xf  # take 4 bits
        mode = 1 if self.mode == ModeEnum.SINGLE_ENDED else 0

        data = (reg << 7) | (scan << 5) | (channelNum << 1) | (mode << 0)
        bytesWritten = self.getProvider().WriteByte(self.addr, data)
        if bytesWritten != 1:
            return GT_FAIL

        # Read
        data = self.getProvider().ReadData(self.addr, nBytes)

        val = 0
        for i in range(len(data)):
            val = val | (data[nBytes - 1 - i] << (i * 8))

        return val

class A2D_Ch:
    pass

class A2D_Ch(EmModel):
    valid = False
    measureType = ''
    name = ''
    mult = 0
    div = 0
    offset = 0
    num = 0

    def __init__(self, elm, parent, connId):
        super(A2D_Ch, self).__init__(elm, parent, connId)
        if elm is not None:
            self.valid = Models_Validator.validType(self.getFirstChildElement('valid'))
            self.measureType = Models_Validator.measureType(self.getFirstChildElement('measure_type'))
            self.name = self.getFirstChildElement('name')
            self.mult = Models_Validator.nonNegativeInteger(self.getFirstChildElement('mult'))
            self.div = Models_Validator.nonNegativeInteger(self.getFirstChildElement('div'))
            self.offset = Models_Validator.nonNegativeInteger(self.getFirstChildElement('offset'))
            self.num = Models_Validator.nonNegativeInteger(self.getAttribute('num'), 11)

    def getInfo(self) -> dict:
        res = {
            'name': self.name,
            'measureType': self.measureType
        }
        return res
