import re
from sys import maxsize
from Marvell.EMClientPy.src.ElectricalManagmentModels.Model_Enums import *


def getEnumValue(e):
    return e.value


class Models_Validator(object):
    PLD_TYPE_Valid_Values = \
        {
            PLDTypeEnum.TC1: [0x0, 0x1, 0x2]
        }

    @staticmethod
    def validationError():
        raise IOError("The values are not complaint with the schema")

    @staticmethod
    def validType(text):
        if text is None:
            return None
        elif text == "true" or text == '1':
            return True
        elif text == 'false' or text == '0':
            return False
        else:
            Models_Validator.validationError()

    @staticmethod
    def vref(text):
        if text is not None and text != "internal" and text != "external":
            Models_Validator.validationError()
        return text

    @staticmethod
    def muxType(text):
        if text != "PCA9544" and text != "PCA9548":
            Models_Validator.validationError()
        return text

    @staticmethod
    def start(text):
        if text != "enable" and text != "disable":
            Models_Validator.validationError()
        return text

    @staticmethod
    def voltType(text):
        if text is None:
            return None
        f = float(text)
        if f < 0:
            Models_Validator.validationError()
        return f

    @staticmethod
    def addrType(text):
        pattern = r'0[xX][0-9A-Fa-f]{1,2}'
        addrText = Models_Validator.pattern(pattern, text)
        return int(addrText, 16)

    @staticmethod
    def measureType(text):
        if text != getEnumValue(MeasureTypeEnum.VOLT) and \
                text != getEnumValue(MeasureTypeEnum.AMP) and \
                text != getEnumValue(MeasureTypeEnum.mV) and \
                text != getEnumValue(MeasureTypeEnum.mA):
            Models_Validator.validationError()
        return text

    @staticmethod
    def marginSelection(text):
        if text is None:
            return None
        if text != getEnumValue(MarginSelectionEnum.HIGH) and \
                text != getEnumValue(MarginSelectionEnum.LOW):
            Models_Validator.validationError()
        return text

    @staticmethod
    def polarityType(text, func):
        if text is not None:
            if text != getEnumValue(PolarityTypeEnum.REGULAR) and \
                    text != getEnumValue(PolarityTypeEnum.INVERSE):
                Models_Validator.validationError()
            return text
        else:
            if func == IOFuncTypeEnum.BoardPwr.name:
                return PolarityTypeEnum.INVERSE
            else:
                return PolarityTypeEnum.REGULAR

    @staticmethod
    def funcType(text):
        if text is None:
            return None
        if text != getEnumValue(IOFuncTypeEnum.FuncError) and \
                text != getEnumValue(IOFuncTypeEnum.BoardReset) and \
                text != getEnumValue(IOFuncTypeEnum.DutPwr) and \
                text != getEnumValue(IOFuncTypeEnum.BoardPwr) and \
                text != getEnumValue(IOFuncTypeEnum.GePhyReset) and \
                text != getEnumValue(IOFuncTypeEnum.ResetDUT) and \
                text != getEnumValue(IOFuncTypeEnum.BoardPowerStatus) and \
                text != getEnumValue(IOFuncTypeEnum.StartControl) and \
                text != getEnumValue(IOFuncTypeEnum.RdyStatus) and \
                text != getEnumValue(IOFuncTypeEnum.FanPwr) and \
                text != getEnumValue(IOFuncTypeEnum.SetVoltageControl):
            Models_Validator.validationError()
        return text

    # @staticmethod
    # def funcNoSmmType(text):
    #     if text != FuncTypeEnum.BoardReset and \
    #             text != FuncTypeEnum.DutPwr and \
    #             text != FuncTypeEnum.BoardPwr and \
    #             text != FuncTypeEnum.GePhyReset and \
    #             text != FuncTypeEnum.ResetDUT and \
    #             text != FuncTypeEnum.BoardPowerStatus:
    #         Models_Validator.validationError()
    #     return FuncTypeEnum(text)
    #
    # @staticmethod
    # def funcSmmType(text):
    #     if text != FuncTypeEnum.StartControl and \
    #             text != FuncTypeEnum.RdyStatus:
    #         Models_Validator.validationError()
    #     return FuncTypeEnum(text)

    @staticmethod
    def num(text):
        if text != "0" and text != "1":
            Models_Validator.validationError()
        return text

    @staticmethod
    def pattern(pattern, text):
        if text is None:
            return None
        match = re.match(pattern, text)
        if match is None or match.endpos != len(text):
            Models_Validator.validationError()
        return text

    @staticmethod
    def nonNegativeInteger(text, _max=maxsize, _min=0):
        if text is None:
            return None
        num = int(text)
        if num > _max or num < _min:
            Models_Validator.validationError()
        return num

    @staticmethod
    def float(text, _max=maxsize, _min=0):
        if text is None:
            return None
        num = float(text)
        if num > _max or num < _min:
            Models_Validator.validationError()
        return num

    @staticmethod
    def arrayLength(arr, _max, _min=0):
        if len(arr) < _min or len(arr) > _max:
            Models_Validator.validationError()

    @staticmethod
    def isValidPLDModeValue(pld_type: PLDTypeEnum, mode_value: int):
        #pld_type: PLDModeEnum = PLDModeEnum(pld_type)
        return mode_value in Models_Validator.PLD_TYPE_Valid_Values[pld_type]
