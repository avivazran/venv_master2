from Marvell.PyMIBS.parser import parser
from Marvell.PyMIBS.Common.utilities import *

try:
    from Marvell.CommunicationService.HighCommunicationLayer.CommunicationManagement import \
        CommunicationManagement as cm
    from Marvell.CommunicationService.Common.Types import CommunicationType as ct
except Exception as e:
    from Marvell.PyMIBS.Common.ImportExternal import import_external

    import_external('CommunicationService')
    from Marvell.CommunicationService.HighCommunicationLayer.CommunicationManagement import \
        CommunicationManagement as cm
    from Marvell.CommunicationService.Common.Types import CommunicationType as ct


class cli_handle(object):
    port = "10000"
    ip = "127.0.0.1"
    # family = "" #"TL10"\"Prestera"
    ac5p_xml = "ac5p_db.xml"

    # the family will be given as parameter to all functions
    def getBasicCommand(self):
        return f"{ROOT}/mibs_common_client --port {self.port} --ip {self.ip} --family " #{self.family} --module "

    def geti2cBasicCommand(self):
        return f"{ROOT}/mibs_cli -p {self.port} -i {self.ip} -m i2c "

    def getEMBasicCommand(self):
        return f"{ROOT}/mibs_cli --port {self.port} --ip {self.ip} --module em --family "

    def getcmisBasicCommand(self):
        return f"{ROOT}/mibs_cmis_client -p {self.port} -i {self.ip} -x "#{ROOT}/{self.ac5p_xml} -c "

    def __init__(self):
        self._host = None
        self._port = None
        self._alias = None
        self._promp = '/ #'
        self._parser = parser()
        self._log: int = 0

    def _login(self, user, password):
        out = ""
        user = "" if user is None else user
        password = "" if password is None else password
        # to define if username and password are required by the board
        try:
            out += cm.GetBufferTillPrompt(self._alias, 10, "login: ").decode('ascii')
        except Exception as e:
            return  # login not required

        try:
            # out += cm.GetBufferTillPrompt(self._alias, 10, "login: ").decode('ascii')
            cm.SendTerminalString(self._alias, user.encode('ascii') + b"\n", waitForPrompt=False)

            out += cm.GetBufferTillPrompt(self._alias,10, b"Password: ").decode('ascii')
            cm.SendTerminalString(self._alias, password.encode('ascii') + b"\n", waitForPrompt=False)

        except Exception as e:
            raise Exception(f"Failed to login using username={0}, password={password}. Error:{str(e)}")
        finally:
            if self._log == 1:
                print(debug(f"[Login]  {out}"))

        self._promp = ':~#'  # worked- around : TL10

    def _clear_buffer(self):
        out = cm.GetBufferTillPrompt(self._alias, timeOutSeconds=10, shellPrompt=self._promp)
        if self._log == 1:
            print(debug(f"[Buffer]  {out.decode('utf-8')}"))

    def _send(self, request):
        cm.SetShellPrompt(self._alias, self._promp)
        return cm.SendCommandAndGetBufferTillPrompt(self._alias, request)

    def setLog(self, logLevel: int):
        self._parser.setLog(logLevel)
        self._log = logLevel

    def is_connected(self):
        if self._alias is None:
            return False
        return cm.is_connected(self._alias)

    def connect(self, host_port: str, user=None, password=None):
        """

        @param host_port: host:port
        @return: On success function returns None. Otherwise Exception will be raised.
        """
        self._host, self._port = self._parser.parse_hostport(host_port)
        if self._port is None:
            raise Exception("Invalid Host:Port")
        self._alias = cm.Connect(ct.PyTelnetOriginLib, port=self._port, ipAddr=self._host)

        # if user is not None and password is not None:
        #     self._promp = ':~#' # worked- around : TL10
        #     self._login(user, password)
        self._login(user, password)

        self._clear_buffer()
        return
        out = self._send(f"{ROOT}/mibs_client -p 10000 -a 127.0.0.1\n")
        if self._log == 1:
            print(debug(f"[Connect]  {out.decode('utf-8')}"))

    def disconnect(self):
        cm.Disconnect(self._alias)

    def i2c_scan(self, bus: int):
        command = self.geti2cBasicCommand() + f"-s -b {bus}"
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_i2c_scan(response)


    def i2c_read(self, bus: int, address, nbytes):
        """

        @param address: Slave Address
        @param nbytes:  Read data size bytes.
        @return:  On success function returns True, list of data. Otherwise False with empty list.
        """

        if nbytes == 0:
            return False
        command = self.geti2cBasicCommand() + f"-r -b {bus} -a {hex(address)} -l {nbytes}"
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_i2c_read(response)

    # def i2c_write(self, bus: int, addr: str, data: str):
    #     command = self.geti2cBasicCommand() + f'-w -b {bus} -a {addr} -d "{data}"'
    #     response = self._send(f"{command}\n")
    #     if self._log == 1:
    #         print(debug(f"[Request]  {command}"))
    #         print(debug(f"[Response]  {response}"))
    #     response = response.decode("utf-8")
    #
    #     return self._parser.parse_i2c_write(response)

    def i2c_write(self,bus: int, address, data, nbytes):
            """

            @param address: Slave Address
            @param data: data to be written (Array of data)
            @param nbytes: Read data size bytes.
            @return:  On success function returns True. Otherwise False.
            """

            # TODO: validate if the written data size == nbytes
            if nbytes == 0:
                return False
            # data_to_write = " ".join(hex(number) for number in data)
            data_to_write = " ".join(hex(number) for number in data[:nbytes])
            # command = f"/pturagashakt/mibs_i2c_client -p 10000 -i 127.0.0.1 -w -b 0x0 -a {hex(address)} -d \"{data_to_write}\""
            command = self.geti2cBasicCommand() + f'-w -b {bus} -a {hex(address)} -d \"{data_to_write}\"'
            # command = f"/pturagashakt/mibs_client -p 10000 -i 127.0.0.1 -w -b 0x0 -a {address} -d \"0x1, 0x3\"\n"

            response = self._send(f"{command}\n")
            if self._log == 1:
                print(debug(f"[Request]  {command}"))
                print(debug(f"[Response]  {response}"))
            response = response.decode("utf-8")

            return self._parser.parse_i2c_write(response)


    def i2c_write_read(self, bus: int, address, regAddress, nbytes):
        """

        @param address: Slave Address
        @param regAddress: Register Address
        @param nbytes:  Read data size bytes.
        @return:  On success function returns True, list of data. Otherwise False with empty list.
        """

        if nbytes == 0:
            return False

        command = self.geti2cBasicCommand() + f'-w -b {bus} -a {hex(address)} -d \"{hex(regAddress)}\" -r -l {nbytes}'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_i2c_write_read(response)

    def temp_read_all(self, familyType: str):
        command = self.getBasicCommand() + f"{familyType} --module temp"
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_temp_read_all(response)

    def temp_read_specific(self, index: int, familyType: str):
        command = self.getBasicCommand() + f"{familyType} --module temp --index {index}"
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_temp_read_specific(response)

    def fan_error(self, familyType: str):
        command = self.getBasicCommand() + f"{familyType} --module fan --error"
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_fan_error(response)

    def fan_control(self, familyType: str):
        command = self.getBasicCommand() + f"{familyType} --module fan --control"
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_fan_control(response)

    def fan_read_all(self, familyType: str):
        command = self.getBasicCommand() + f"{familyType} --module fan --read"
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_fan_read_all(response)

    def fan_read_specific(self, index: int, familyType: str):
        command = self.getBasicCommand() + f"{familyType} --module fan --read --index {index}"
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_fan_read_specific(response)

    def fan_write_specific(self, index: int, data: str, familyType: str):
        if index not in range(8):
            raise Exception("the fan index should be in range 0-7, because there are exactly 8 fans in TL10")
        command = self.getBasicCommand() + f'{familyType} --module fan --write --index {index} --data "{data}"'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_fan_write_specific(response)

    def fan_write_multiple(self, data: str, familyType: str):
        tmpData = data.strip().lstrip()
        if len(tmpData.split(' ')) != 8:
            raise Exception("there should be exactly 8 fans in TL10")

        command = self.getBasicCommand() + f'{familyType} --module fan --write --data "{data}"'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_fan_write_multiple(response)

    def fpga_read(self, offset: str, familyType: str):
        command = self.getBasicCommand() + f'{familyType} --module fan --read --offset {offset}'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_fpga_read(response)

    def fpga_write(self, offset: str, data: str, familyType: str):
        command = self.getBasicCommand() + f'{familyType} --module fan --write --offset {offset} --data "{data}"'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_fpga_write(response)

    def em_set_vdd(self, pm: int, mv: float, I2CBusNumber: int, familyType: str, deviceName: str):
        xml = getEM_XML_Path(deviceName)
        if xml is None:
            return False, None
        command = self.getEMBasicCommand() + f'{familyType} --xml {ROOT}/{xml} --vdd --write --mv {mv} --pm {pm} --bus {I2CBusNumber}'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_em_set_vdd(response)

    def em_get_vdd(self, pm: int, I2CBusNumber: int, familyType: str, deviceName: str):
        xml = getEM_XML_Path(deviceName)
        if xml is None:
            return False, None
        command = self.getEMBasicCommand() + f'{familyType} --xml {ROOT}/{xml} --vdd  --read --pm {pm} --bus {I2CBusNumber}'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_em_get_vdd(response)

    def em_get_idd(self, pm: int, I2CBusNumber: int, familyType: str, deviceName: str):
        xml = getEM_XML_Path(deviceName)
        if xml is None:
            return False, None
        command = self.getEMBasicCommand() + f'{familyType} --xml {ROOT}/{xml} --idd --read --pm {pm} --bus {I2CBusNumber}'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_em_get_idd(response)

    def cmis_get_vendor_name(self, module_number: int, deviceName: str):
        xml = getCMIS_XML_Path(deviceName)
        if xml is None:
            return False, None
        command = self.getcmisBasicCommand() + f'{ROOT}/{xml} -c "cmis_get_vendor_name {module_number}"'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_cmis_get_vendor_name(response)

    def cmis_get_temperature(self, module_number: int, deviceName: str):
        xml = getCMIS_XML_Path(deviceName)
        if xml is None:
            return False, None
        command = self.getcmisBasicCommand() + f'{ROOT}/{xml} -c "cmis_get_temperature {module_number}"'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_cmis_get_temperature(response)

    def cmis_get_rx_cdr_lol(self, module_number: int, deviceName: str):
        xml = getCMIS_XML_Path(deviceName)
        if xml is None:
            return False, None
        command = self.getcmisBasicCommand() + f'{ROOT}/{xml} -c "cmis_get_rx_cdr_lol {module_number}"'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_cmis_get_rx_cdr_lol(response)

    def cmis_get_tx_disable(self, module_number: int, deviceName: str):
        xml = getCMIS_XML_Path(deviceName)
        if xml is None:
            return False, None
        command = self.getcmisBasicCommand() + f'{ROOT}/{xml} -c "cmis_get_tx_disable {module_number}"'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_cmis_get_tx_disable(response)

    def cmis_set_tx_disable(self, module_number: int, lane: int, enableOrDisable: int, deviceName: str):
        xml = getCMIS_XML_Path(deviceName)
        if xml is None:
            return False, None
        command = self.getcmisBasicCommand() + f'{ROOT}/{xml} -c "cmis_set_tx_disable {module_number} {lane} {enableOrDisable}"'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_cmis_set_tx_disable(response)

    def cmis_get_tx_fir(self, module_number: int, lane: int, deviceName: str):
        xml = getCMIS_XML_Path(deviceName)
        if xml is None:
            return False, None
        command = self.getcmisBasicCommand() + f'{ROOT}/{xml} -c "cmis_get_tx_fir {module_number} {lane}"'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_cmis_get_tx_fir(response)

    def cmis_set_tx_fir(self, module_number: int, lane: int, pre: str, post: str, amp: str, deviceName: str):
        xml = getCMIS_XML_Path(deviceName)
        if xml is None:
            return False, None
        command = self.getcmisBasicCommand() + f'{ROOT}/{xml} -c "cmis_set_tx_fir {module_number} {lane} {pre} {post} {amp}"'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_cmis_set_tx_fir(response)

    def cmis_get_register(self, module_number: int, page: str, bank: int, offset: int, deviceName: str):
        xml = getCMIS_XML_Path(deviceName)
        if xml is None:
            return False, None
        command = self.getcmisBasicCommand() + f'{ROOT}/{xml} -c "cmis_get_register {module_number} {page} {bank} {offset}"'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_cmis_get_register(response)

    def cmis_set_register(self, module_number: int, page: str, bank: int, offset: int, data: str, deviceName: str):
        xml = getCMIS_XML_Path(deviceName)
        if xml is None:
            return False, None
        command = self.getcmisBasicCommand() + f'{ROOT}/{xml} -c "cmis_set_register {module_number} {page} {bank} {offset} {data}"'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_cmis_set_register(response)

    def cmis_get_loopback_capabilities(self, module_number: int, deviceName: str):
        xml = getCMIS_XML_Path(deviceName)
        if xml is None:
            return False, None
        command = self.getcmisBasicCommand() + f'{ROOT}/{xml} -c "cmis_get_loopback_capabilities {module_number}"'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_cmis_get_loopback_capabilities(response)

    def cmis_set_loopback(self, module_number: int, lane: int, loopback: str, deviceName: str):
        xml = getCMIS_XML_Path(deviceName)
        if xml is None:
            return False, None
        command = self.getcmisBasicCommand() + f'{ROOT}/{xml} -c "cmis_set_loopback {module_number} {lane} {loopback}"'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_cmis_set_loopback(response)

    def cmis_get_diagnostics_capabilities(self, module_number: int, deviceName: str):
        xml = getCMIS_XML_Path(deviceName)
        if xml is None:
            return False, None
        command = self.getcmisBasicCommand() + f'{ROOT}/{xml} -c "cmis_get_diagnostics_capabilities {module_number}"'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_cmis_get_diagnostics_capabilities(response)

    def cmis_set_diagnostics(self, module_number: int, prbs_type: int, startOrStop: int, deviceName: str):
        xml = getCMIS_XML_Path(deviceName)
        if xml is None:
            return False, None
        command = self.getcmisBasicCommand() + f'{ROOT}/{xml} -c "cmis_set_diagnostics {module_number} {prbs_type} {startOrStop}"'
        response = self._send(f"{command}\n")
        if self._log == 1:
            print(debug(f"[Request]  {command}"))
            print(debug(f"[Response]  {response}"))
        response = response.decode("utf-8")

        return self._parser.parse_cmis_set_diagnostics(response)

# hdl = cli_handle()
# hdl.setlog(False)
# hdl.connect("10.5.217.207:23")
#
# s, d = hdl.i2c_scan()
# print("scan:", s, d)
# s = hdl.i2c_write(0x70, [0x4], 1)
# print("write:", s)
#
# s, d = hdl.i2c_read(0x70, 1)
# print("read:", s, d)
#
# s = hdl.i2c_write(0x70, [0x1], 1)
# print("write:", s)
#
# s, d = hdl.i2c_read(0x70, 1)
# print("read:", s, d)
