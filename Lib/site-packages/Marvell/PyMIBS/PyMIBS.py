from Marvell.PyMIBS.cli_handle import cli_handle
from Marvell.PyMIBS.Common.Constants import *
from Marvell.PyMIBS.Common.utilities import debug

class PyMIBSProvider(object):
    def __init__(self):
        self.log_level = 0
        self._connected = False
        self._handle = cli_handle()
        self._i2c_bus = 0 # Prestira connected to 0, TL10 to 1

    def setLog(self, logLevel: int):
        self.log_level = logLevel
        self._handle.setLog(logLevel)

    def Connect(self, host_port: str):#, user=None, password=None):
        """
        @param host_port: host and port of the MIBS clint with format host:port
        @return: On success function returns True. Otherwise Exception will be raised.
        """
        try:

            if type(host_port) is not str or host_port.index(':') == -1:
                raise Exception(f"Wrong format. Key should be in host:port format. e.g, 127.0.0.1:12345")

            #===========================
            # the user name and password should be passed
            user = None
            password = None
            infolist = host_port.split(",")
            host_port = infolist[0]
            if len(infolist) > 1:
                user = infolist[1]
                password = infolist[2]
                self._i2c_bus = 1
            #===========================
            self._handle.connect(host_port, user=user, password=password)
            self._connected = True
            return True
        except Exception as e:
            raise Exception(f"Failed to connect {id}.\n Error: {str(e)}")

    def Disconnect(self):
        """

        @return: On success function returns None. Otherwise Exception will be raised.
        """
        try:
            self._handle.disconnect()
        finally:
            self._connected = False

    #******************************************** I2C ********************************************#

    def I2C_Read(self, slaveAddr, memAddr, memAddrSz, size):
        """
        Note: If memAddrSz is zero "Memory Address Write" stage will be skipped.

        @param slaveAddr: Slave Address
        @param memAddr:  Memory Address. Will be shifted out in "Memory Address Write" stage MSB first
        @param memAddrSz: Memory Address size bytes
        @param size:  Read data size bytes.
        @return: Buffer read data if success. Otherwise Exception will be raised.
        """
        try:
            if self.log_level == 1:
                msg = f"Try to execute i2c read, slaveAddr={hex(slaveAddr)}, ma={hex(memAddr)}, ma_sz={memAddrSz},nBytes={size} "
                print(debug(msg))

            if 0 != memAddrSz:
                #rc = self._handle.i2c_write(slaveAddr, [memAddr], memAddrSz)
                rc, data = self._handle.i2c_write_read(self._i2c_bus, slaveAddr, memAddr,size)
                if not rc:
                    raise Exception(f"Failed to write address {hex(memAddr)}")
            else:
                rc, data = self._handle.i2c_read(self._i2c_bus, slaveAddr, size)
                if not rc:
                    raise Exception(f"Failed to read data from slave address {hex(slaveAddr)}")

            if self.log_level == 1:

                msg = f"Try to execute i2c read, success. data={[hex(d) for d in list(data)]} nBytes={size} "
                print(debug(msg))

            return data
        except Exception as e:
            raise Exception(f"Failed to read I2C.\n Error: {str(e)}")



    def I2C_Scan(self):
        """

        @return: On success function returns list of slave device addresses . Otherwise Exception will be raised.
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute i2c scan."
                print(debug(msg))
            rc, slaves = self._handle.i2c_scan(self._i2c_bus)
            if not rc:
                raise Exception(f"Failed to scan I2C.")
            if self.log_level == 1:
                msg = f"Try to execute i2c write, success. slave Addrresses={[hex(sa) for sa in slaves]}"
                print(debug(msg))
            return slaves
        except Exception as e:
            raise Exception(f"Failed to scan I2C.\n Error: {str(e)}")




    def I2C_Write(self, slaveAddr, memAddr, memAddrSz, buffer, size):
        """
        Note: If memAddrSz is zero "Memory Address Write" stage will be skipped.

        @param slaveAddr: Slave Address
        @param memAddr:  Memory Address. Will be shifted out in "Memory Address Write" stage MSB first
        @param memAddrSz: Memory Address size bytes
        @param buffer: Buffer for data to be written (Array of data)
        @param size:  Write data size bytes.

        @return: On success function returns True. Otherwise Exception will be raised.
        """
        try:
            if self.log_level == 1:
                msg = f"Try to execute i2c write, slaveAddr={hex(slaveAddr)}, ma={hex(memAddr)}, ma_sz={memAddrSz}, datta={[hex(d) for d in buffer]} nBytes={size}"
                print(debug(msg))

            if memAddrSz != 0:
                rc = self._handle.i2c_write(self._i2c_bus, slaveAddr, [memAddr], memAddrSz)
                if not rc:
                    raise Exception(f"Failed to write address {hex(memAddr)}")
            rc = self._handle.i2c_write(self._i2c_bus, slaveAddr, buffer, size)
            if not rc:
                raise Exception(f"Failed to write data {[hex(e) for e in buffer]}")

            if self.log_level == 1:
                msg = f"Try to execute i2c write, success."
                print(debug(msg))

            return rc
        except Exception as e:
            raise Exception(f"Failed to Write I2C.\n Error: {str(e)}")


    #******************************************** Temperature ********************************************#
    def Read_all_temperature_sensors(self, familyType: str):
        """
        @param familyType: familyType - 'TL10' / 'Prestera'
        @return: On success function returns a Dictionary - the key is the index, the value is a Dictionary with keys: "addr", "offset" and "value".
             addr and offset values will be intigers in base 10.
        The value is the temperature sensors for the specific index.
        Otherwise Exception will be raised.
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute temperature read."
                print(debug(msg))
            rc, data = self._handle.temp_read_all(familyType)
            if not rc:
                raise Exception(f"Dailed to read temperature.")
            if self.log_level == 1:
                msg = f"Try to execute temperature read, success. temperature={data}"
                print(debug(msg))
            return data
        except Exception as e:
            raise Exception(f"Failed to read temperature.\n Error: {str(e)}")

    def Read_specific_temperature_sensor(self, index: int, familyType: str):
        """
        @param index: index
        @param familyType: familyType - 'TL10' / 'Prestera'
        @return: On success function returns a Dictionary - the key is the index, the value is a Dictionary with keys: "addr", "offset" and "value".
             addr and offset values will be intigers in base 10.
                 The value is the temperature sensors for the specific index.
                 Otherwise Exception will be raised.
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute temperature read. index={index}"
                print(debug(msg))
            rc, data = self._handle.temp_read_specific(index, familyType)
            if not rc:
                raise Exception(f"Dailed to read temperature.")
            if self.log_level == 1:
                msg = f"Try to execute temperature read, success. temperature={data}"
                print(debug(msg))
            return data
        except Exception as e:
            raise Exception(f"Failed to read temperature.\n Error: {str(e)}")

    #******************************************** Fan ********************************************#
    def Read_FAN_error_status_register(self, familyType: str):
        """
        @param familyType: familyType - 'TL10' / 'Prestera'
        @return: On success function returns a Dictionary - the key is the index, the value is a Dictionary with keys: "addr", "offset" and "value".
             addr and offset values will be intigers in base 10.
             The offset is not relevant, so its value is None
             The value is the FAN error status register - N means No, Y means Yes
             Otherwise Exception will be raised.
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute fan error."
                print(debug(msg))
            rc, data = self._handle.fan_error(familyType)
            if not rc:
                raise Exception(f"Dailed to fan error.")
            if self.log_level == 1:
                msg = f"Try to execute fan error, success. data={data}"
                print(debug(msg))
            return data
        except Exception as e:
            raise Exception(f"Failed to execute fan error.\n Error: {str(e)}")

    def Read_FAN_control_status_register(self, familyType: str):
        """
        @param familyType: familyType - 'TL10' / 'Prestera'
        @return: On success function returns a Dictionary - the key is the index, the value is a Dictionary with keys: "addr", "offset" and "value".
             addr and offset values will be intigers in base 10.
             the index will be '0x1f'. it indicates all fans (not a specific fan index)
             The value is the FAN control status register.
             Otherwise Exception will be raised.
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute fan control."
                print(debug(msg))
            rc, data = self._handle.fan_control(familyType)
            if not rc:
                raise Exception(f"Dailed to fan control.")
            if self.log_level == 1:
                msg = f"Try to execute fan control, success. data={data}"
                print(debug(msg))
            return data
        except Exception as e:
            raise Exception(f"Failed to execute fan control.\n Error: {str(e)}")

    def Read_FAN_speed_all(self, familyType: str):
        """
        @param familyType: familyType - 'TL10' / 'Prestera'
        @return: On success function returns a Dictionary - the key is the index, the value is a Dictionary with keys: "addr", "offset" and "value".
             addr and offset values will be intigers in base 10.
             The value is the FAN speed for the specific index.
             Otherwise Exception will be raised.
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute fan read"
                print(debug(msg))
            rc, data = self._handle.fan_read_all(familyType)
            if not rc:
                raise Exception(f"Dailed to read fan.")
            if self.log_level == 1:
                msg = f"Try to execute fan read, success. fan={data}"
                print(debug(msg))
            return data
        except Exception as e:
            raise Exception(f"Failed to read fan.\n Error: {str(e)}")

    def Read_FAN_speed_specific(self, index: int, familyType: str):
        """
        @param index: index
        @param familyType: familyType - 'TL10' / 'Prestera'
        @return: On success function returns a Dictionary - the key is the index, the value is a Dictionary with keys: "addr", "offset" and "value".
             addr and offset values will be intigers in base 10.
             The output is dictionary of only one element for future convention, if more one index can be provided by the user.
             The value is the FAN speed for the specific index.
             Otherwise Exception will be raised.
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute fan read. index={index}"
                print(debug(msg))
            rc, data = self._handle.fan_read_specific(index, familyType)
            if not rc:
                raise Exception(f"Dailed to read fan.")
            if self.log_level == 1:
                msg = f"Try to execute fan read, success. fan={data}"
                print(debug(msg))
            return data
        except Exception as e:
            raise Exception(f"Failed to read fan.\n Error: {str(e)}")

    def Write_FAN_speed_specific(self, index: int, data: str, familyType: str):
        """
        @param index: index
        @param data: data
        @param familyType: familyType - 'TL10' / 'Prestera'
        @return: On success function returns a Dictionary - the key is the index, the value is a Dictionary with keys: "addr", "offset" and "value".
             addr and offset values will be intigers in base 10.
             the output is dictionary of only one element for future convention, if more one index can be provided by the user.
             The value is the written FAN speed data for the specific index as intigers in base 10..
             Otherwise Exception will be raised.
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute fan write. index={index}, data={data}"
                print(debug(msg))
            rc, resData = self._handle.fan_write_specific(index, data, familyType)
            if not rc:
                raise Exception(f"Dailed to fan write.")
            if self.log_level == 1:
                msg = f"Try to execute write fan, success. fan={resData}" #TODO CHEN - no return value for write?
                print(debug(msg))
            return resData
        except Exception as e:
            raise Exception(f"Failed to write fan.\n Error: {str(e)}")

    def Write_FAN_speed_multiple(self, data: str, familyType: str):
        """
        @param data: 8 hex numbers of values to be written, all in one string separated be space
        @param familyType: familyType - 'TL10' / 'Prestera'
        @return: On success function returns a Dictionary - the key is the index, the value is a Dictionary with keys: "addr", "offset" and "value".
             addr and offset values will be intigers in base 10.
             The value is the written FAN speed data for the specific index as intigers in base 10..
             Otherwise Exception will be raised.
        """
        try:
            if self.log_level == 1:
                msg = f"Try to execute fan write. data={data}"
                print(debug(msg))
            rc, resData = self._handle.fan_write_multiple(data, familyType)
            if not rc:
                raise Exception(f"Dailed to fan write.")
            if self.log_level == 1:
                msg = f"Try to execute write fan, success. fan={resData}" #TODO CHEN - no return value for write?
                print(debug(msg))
            return resData
        except Exception as e:
            raise Exception(f"Failed to write fan.\n Error: {str(e)}")

    #******************************************** FPGA ********************************************#
    def Read_FPGA_register_offset(self, offset: str, familyType: str):
        """
        @param offset: offset as Hex value.
        @param familyType: familyType - 'TL10' / 'Prestera'
        @return: On success function returns a Dictionary - the key is the index, the value is a Dictionary with keys: "addr", "offset" and "value".
             addr and offset values will be intigers in base 10.
             The value is the FPGA register data.
             Otherwise Exception will be raised.
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute fpga read. offset={offset}"
                print(debug(msg))
            rc, data = self._handle.fpga_read(offset, familyType)
            if not rc:
                raise Exception(f"Dailed to read fpga.")
            if self.log_level == 1:
                msg = f"Try to execute fpga read, success. fpga={data}"
                print(debug(msg))
            return data
        except Exception as e:
            raise Exception(f"Failed to read fpga.\n Error: {str(e)}")

    def Write_FPGA_register_offset(self, offset: str, data: str, familyType: str):
        """
        @param offset: offset as Hex value.
        @param data: data as Hex value.
        @param familyType: familyType - 'TL10' / 'Prestera'
        @return: On success function returns a Dictionary - the key is the index, the value is a Dictionary with keys: "addr", "offset" and "value".
             addr and offset values will be intigers in base 10.
             The value is the FPGA register data to be written.
             Otherwise Exception will be raised.
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute fpga write. offset={offset}, data={data}"
                print(debug(msg))
            rc, resData = self._handle.fpga_write(offset, data, familyType)
            if not rc:
                raise Exception(f"Dailed to write fpga.")
            if self.log_level == 1:
                msg = f"Try to execute fpga write, success. fpga={resData}"
                print(debug(msg))
            return resData
        except Exception as e:
            raise Exception(f"Failed to write fpga.\n Error: {str(e)}")

    #******************************************** EM VDD/IDD ********************************************#
    def EMsetVDD(self, pm, mv, I2CBusNumber: int, familyType: str, deviceName: str):
        """
        @param pm: power module
        @param mv: Voltage to be writen in mV
        @param I2CBusNumber: I2CBusNumber option has been added to EM CLI since in TL10 DB, all I2C devices are connected to I2C Bus 1
        @param familyType: familyType - 'TL10' / 'Prestera'
        @param deviceName: DeviceName can be "AC5", "AC5X", "AC5P", "IM_L", "IM_M" or "TL10"
        @return: On success function returns a float indicating to the vdd was writen .
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute em set vdd. pm={pm}, mv={mv}, deviceName={deviceName}"
                print(debug(msg))
            rc, resData = self._handle.em_set_vdd(pm, mv, I2CBusNumber, familyType, deviceName)
            if not rc:
                raise Exception(f"Dailed to execute em set vdd.")
            if self.log_level == 1:
                msg = f"Try to execute em set vdd, success. vdd set to={resData}"
                print(debug(msg))
            return resData
        except Exception as e:
            raise Exception(f"Failed to execute em set vdd.\n Error: {str(e)}")

    def EMgetVDD(self, pm, I2CBusNumber: int, familyType: str, deviceName: str):
        """
        @param pm: power module
        @param I2CBusNumber: I2CBusNumber option has been added to EM CLI since in TL10 DB, all I2C devices are connected to I2C Bus 1
        @param familyType: familyType - 'TL10' / 'Prestera'
        @param deviceName: DeviceName can be "AC5", "AC5X", "AC5P", "IM_L", "IM_M" or "TL10"
        @return: On success function returns a float indicating the vdd.
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute em get vdd. pm={pm}, deviceName={deviceName}"
                print(debug(msg))
            rc, resData = self._handle.em_get_vdd(pm, I2CBusNumber, familyType, deviceName)
            if not rc:
                raise Exception(f"Dailed to execute em get vdd.")
            if self.log_level == 1:
                msg = f"Try to execute em set vdd, success. vdd is {resData}"
                print(debug(msg))
            return resData
        except Exception as e:
            raise Exception(f"Failed to execute em get vdd.\n Error: {str(e)}")

    def EMgetIDD(self, pm, I2CBusNumber: int, familyType: str, deviceName: str):
        """
        @param pm: power module
        @param I2CBusNumber: I2CBusNumber option has been added to EM CLI since in TL10 DB, all I2C devices are connected to I2C Bus 1
        @param familyType: familyType - 'TL10' / 'Prestera'
        @param deviceName: DeviceName can be "AC5", "AC5X", "AC5P", "IM_L", "IM_M" or "TL10"
        @return: On success function returns a float indicating the idd.
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute em get idd.pm={pm}, deviceName={deviceName}"
                print(debug(msg))
            rc, resData = self._handle.em_get_idd(pm, I2CBusNumber, familyType, deviceName)
            if not rc:
                raise Exception(f"Dailed to execute em get idd.")
            if self.log_level == 1:
                msg = f"Try to execute em set vdd, success. idd is {resData}"
                print(debug(msg))
            return resData
        except Exception as e:
            raise Exception(f"Failed to execute em get idd.\n Error: {str(e)}")

    #******************************************** CMIS ********************************************#
    def cmis_get_vendor_name(self, module_number: int, deviceName: str):
        """
        @param module_number: module_number
        @param deviceName: DeviceName can be "AC5", "AC5X", "AC5P", "IM_L", "IM_M" or "TL10"
        @return: On success function returns a dictionary element, the keys are - "Name", "PartNumber", "Revision" & "SerialNumber", and the values are the CLI return value.
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute cmis_get_vendor_name. module_number={module_number}, deviceName={deviceName}"
                print(debug(msg))
            rc, resData = self._handle.cmis_get_vendor_name(module_number, deviceName)
            if not rc:
                raise Exception(f"Dailed to execute cmis_get_vendor_name. module_number is {module_number}, deviceName={deviceName}")
            if self.log_level == 1:
                msg = f"Try to execute cmis_get_vendor_name, success. the result is {resData}"
                print(debug(msg))
            return resData
        except Exception as e:
            raise Exception(f"Failed to execute cmis_get_vendor_name .\n Error: {str(e)}")

    def cmis_get_temperature(self, module_number: int, deviceName: str):
        """
        @param module_number: module_number
        @param deviceName: DeviceName can be "AC5", "AC5X", "AC5P", "IM_L", "IM_M" or "TL10"
        @return: On success function returns a float indicating the cmis temperature.
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute cmis_get_temperature. module_number={module_number}, deviceName={deviceName}"
                print(debug(msg))
            rc, resData = self._handle.cmis_get_temperature(module_number, deviceName)
            if not rc:
                raise Exception(f"Dailed to execute cmis_get_temperature. module_number is {module_number}, deviceName={deviceName}")
            if self.log_level == 1:
                msg = f"Try to execute cmis_get_temperature success. the result is {resData}"
                print(debug(msg))
            return resData
        except Exception as e:
            raise Exception(f"Failed to execute cmis_get_temperature .\n Error: {str(e)}")

    def cmis_get_rx_cdr_lol(self, module_number: int, deviceName: str):
        """
        @param module_number: module_number
        @param deviceName: DeviceName can be "AC5", "AC5X", "AC5P", "IM_L", "IM_M" or "TL10"
        @return: On success function returns a dictionary element, whit keys the lane Number, and the values are the status result
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute cmis_get_rx_cdr_lol. module_number={module_number}, deviceName={deviceName}"
                print(debug(msg))
            rc, resData = self._handle.cmis_get_rx_cdr_lol(module_number, deviceName)
            if not rc:
                raise Exception(f"Dailed to execute cmis_get_rx_cdr_lol. module_number is {module_number}, deviceName={deviceName}")
            if self.log_level == 1:
                msg = f"Try to execute cmis_get_rx_cdr_lol success. the result is {resData}"
                print(debug(msg))
            return resData
        except Exception as e:
            raise Exception(f"Failed to execute cmis_get_rx_cdr_lol .\n Error: {str(e)}")

    def cmis_get_tx_disable(self, module_number: int, deviceName: str):
        """
        @param module_number: module_number
        @param deviceName: DeviceName can be "AC5", "AC5X", "AC5P", "IM_L", "IM_M" or "TL10"
        @return: On success function returns an integer (base 10) indicating the Lane Disable Status
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute cmis_get_tx_disable. module_number={module_number}, deviceName={deviceName}"
                print(debug(msg))
            rc, resData = self._handle.cmis_get_tx_disable(module_number, deviceName)
            if not rc:
                raise Exception(f"Dailed to execute cmis_get_tx_disable. module_number is {module_number}, deviceName={deviceName}")
            if self.log_level == 1:
                msg = f"Try to execute cmis_get_tx_disable success. the result is {resData}"
                print(debug(msg))
            return resData
        except Exception as e:
            raise Exception(f"Failed to execute cmis_get_tx_disable .\n Error: {str(e)}")

    def cmis_set_tx_disable(self, module_number: int, lane: int, enableOrDisable: int, deviceName: str):
        """
        @param module_number: module_number
        @param lane: lane
        @param: enableOrDisable - 1-disable 0-enable
        @param deviceName: DeviceName can be "AC5", "AC5X", "AC5P", "IM_L", "IM_M" or "TL10"
        @return: On success function returns an integer (base 10) indicating the Lane Disable Status after setting
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute cmis_set_tx_disable. module_number is {module_number}, lane is {lane}, enableDisable is {enableOrDisable}, deviceName={deviceName}"
                print(debug(msg))
            rc, resData = self._handle.cmis_set_tx_disable(module_number, lane, enableOrDisable, deviceName)
            if not rc:
                raise Exception(f"Dailed to execute cmis_set_tx_disable. module_number is {module_number}, lane is {lane}, enableDisable is {enableOrDisable}, deviceName={deviceName}")
            if self.log_level == 1:
                msg = f"Try to execute cmis_set_tx_disable success. the result is {resData}"
                print(debug(msg))
            return resData
        except Exception as e:
            raise Exception(f"Failed to execute cmis_set_tx_disable .\n Error: {str(e)}")

    def cmis_get_tx_fir(self, module_number: int, lane: int, deviceName: str):
        """
        @param module_number: module_number
        @param lane: lane
        @param deviceName: DeviceName can be "AC5", "AC5X", "AC5P", "IM_L", "IM_M" or "TL10"
        @return: On success function returns a dictionary element, the key is the lane number, and the value is a dictionary
         – keys are “PRE”, ”POST” & “AMPLITUDE”, and the values are their value returned from the command as integer (base 10).
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute cmis_get_tx_fir. module_number is {module_number}, lane is {lane}, deviceName={deviceName}"
                print(debug(msg))
            rc, resData = self._handle.cmis_get_tx_fir(module_number, lane, deviceName)
            if not rc:
                raise Exception(f"Dailed to execute cmis_get_tx_fir. module_number is {module_number}, lane is {lane}, deviceName={deviceName}")
            if self.log_level == 1:
                msg = f"Try to execute cmis_get_tx_fir success. the result is {resData}"
                print(debug(msg))
            return resData
        except Exception as e:
            raise Exception(f"Failed to execute cmis_get_tx_fir .\n Error: {str(e)}")

    def cmis_set_tx_fir(self, module_number: int, lane: int, pre: str, post: str, amp: str, deviceName: str):
        """
        @param module_number: module_number
        @param lane: lane
        @param pre: pre in hex
        @param post: post in hex
        @param amp: amplitude in hex
        @param deviceName: DeviceName can be "AC5", "AC5X", "AC5P", "IM_L", "IM_M" or "TL10"
        @return: On success function returns a dictionary element, the key is the lane number, and the value is a dictionary
         – keys are “PRE”, ”POST” & “AMPLITUDE”, and the values are their value returned from the command as integer (base 10).
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute cmis_set_tx_fir. module_number is {module_number}, lane is {lane} pre is {pre}, post is {post}, amplitude is {amp}, deviceName={deviceName}"
                print(debug(msg))
            rc, resData = self._handle.cmis_set_tx_fir(module_number, lane, pre, post, amp, deviceName)
            if not rc:
                raise Exception(f"Dailed to execute cmis_set_tx_fir. module_number is {module_number}, lane is {lane} pre is {pre}, post is {post}, amplitude is {amp}, deviceName={deviceName}")
            if self.log_level == 1:
                msg = f"Try to execute cmis_set_tx_fir success. the result is {resData}"
                print(debug(msg))
            return resData
        except Exception as e:
            raise Exception(f"Failed to execute cmis_set_tx_fir .\n Error: {str(e)}")

    def cmis_get_register(self, module_number: int, page: str, bank: int, offset: int, deviceName: str):
        """
        @param module_number: module_number
        @param page: page in hex
        @param bank: bank
        @param offset: offset
        @param deviceName: DeviceName can be "AC5", "AC5X", "AC5P", "IM_L", "IM_M" or "TL10"
        @return: On success function returns a dictionary element – keys are "Module", "Page", "Bank", "Offset" and the
        values returned from the command, in base 10.
        one more key in the dictionary is "RegisterValue", and the value is the data written in the register as an integer.

        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute cmis_get_register. module_number is {module_number}, page is {page}, bank is {bank}, offset is {offset}, deviceName={deviceName}"
                print(debug(msg))
            rc, resData = self._handle.cmis_get_register(module_number, page, bank, offset, deviceName)
            if not rc:
                raise Exception(f"Dailed to execute cmis_get_register. module_number is {module_number}, page is {page}, bank is {bank}, offset is {offset}, deviceName={deviceName}")
            if self.log_level == 1:
                msg = f"Try to execute cmis_get_register success. the result is {resData}"
                print(debug(msg))
            return resData
        except Exception as e:
            raise Exception(f"Failed to execute cmis_get_register .\n Error: {str(e)}")

    def cmis_set_register(self, module_number: int, page: str, bank: int, offset: int, data: str, deviceName: str):
        """
        @param module_number: module_number
        @param page: page in hex
        @param bank: bank
        @param offset: offset
        @param data: data in hex
        @param deviceName: DeviceName can be "AC5", "AC5X", "AC5P", "IM_L", "IM_M" or "TL10"
        @return: On success function returns a dictionary element – keys are "Module", "Page", "Bank", "Offset" and the
        values returned from the command, in base 10.
        one more key in the dictionary is "register value", and the value is the data written in the register as an integer.
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute cmis_set_register. module_number is {module_number}, page is {page}, bank is {bank}, offset is {offset}, data is {data}, deviceName={deviceName}"
                print(debug(msg))
            rc, resData = self._handle.cmis_set_register(module_number, page, bank, offset, data, deviceName)
            if not rc:
                raise Exception(f"Dailed to execute cmis_set_register. module_number is {module_number}, page is {page}, bank is {bank}, offset is {offset}, data is {data}, deviceName={deviceName}")
            if self.log_level == 1:
                msg = f"Try to execute cmis_set_register success. the result is {resData}"
                print(debug(msg))
            return resData
        except Exception as e:
            raise Exception(f"Failed to execute cmis_set_register .\n Error: {str(e)}")

    def cmis_get_loopback_capabilities(self, module_numbe: int, deviceName: str):
        """
        @param module_number: module_number
        @param deviceName: DeviceName can be "AC5", "AC5X", "AC5P", "IM_L", "IM_M" or "TL10"
        @return:
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute cmis_get_loopback_capabilities. module_number is {module_numbe}, deviceName={deviceName}"
                print(debug(msg))
            rc, resData = self._handle.cmis_get_loopback_capabilities(module_numbe, deviceName)
            if not rc:
                raise Exception(f"Dailed to execute cmis_get_loopback_capabilities. module_number is {module_numbe}, deviceName={deviceName}")
            if self.log_level == 1:
                msg = f"Try to execute cmis_get_loopback_capabilities , success."
                print(debug(msg))
            return resData
        except Exception as e:
            raise Exception(f"Failed to execute cmis_get_loopback_capabilities .\n Error: {str(e)}")

    def cmis_set_loopback(self, module_numbe: int, lane: int, loopback: str, deviceName: str):
        """
        @param module_number: module_number
        @param lane: lane
        @param loopback : TX2RX/RX2TX/NONE
        @param deviceName: DeviceName can be "AC5", "AC5X", "AC5P", "IM_L", "IM_M" or "TL10"
        @return:
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute cmis_set_loopback. module_number is {module_numbe}, lane is {lane},loopback is {loopback}  deviceName={deviceName}"
                print(debug(msg))
            rc, resData = self._handle.cmis_set_loopback(module_numbe, lane, loopback, deviceName)
            if not rc:
                raise Exception(f"Dailed to execute cmis_set_loopback. module_number is {module_numbe}, lane is {lane},loopback is {loopback}  deviceName={deviceName}")
            if self.log_level == 1:
                msg = f"Try to execute cmis_set_loopback , success."
                print(debug(msg))
            return resData
        except Exception as e:
            raise Exception(f"Failed to execute cmis_set_loopback .\n Error: {str(e)}")

    def cmis_get_diagnostics_capabilities(self, module_numbe: int, deviceName: str):
        """
        @param module_number: module_number
        @param deviceName: DeviceName can be "AC5", "AC5X", "AC5P", "IM_L", "IM_M" or "TL10"
        @return:
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute cmis_get_diagnostics_capabilities. module_number is {module_numbe}, deviceName={deviceName}"
                print(debug(msg))
            rc, resData = self._handle.cmis_get_diagnostics_capabilities(module_numbe, deviceName)
            if not rc:
                raise Exception(f"Dailed to execute cmis_get_diagnostics_capabilities. . module_number is {module_numbe}, deviceName={deviceName}")
            if self.log_level == 1:
                msg = f"Try to execute cmis_get_diagnostics_capabilities , success."
                print(debug(msg))
            return resData
        except Exception as e:
            raise Exception(f"Failed to execute cmis_get_diagnostics_capabilities .\n Error: {str(e)}")

    def cmis_set_diagnostics(self, module_numbe: int, prbs_type: int, startOrStop: int, deviceName: str):
        """
        @param module_number: module_number
        @param prbs_type - 7/13/31
        @param startOrStop - 1-start 0-stop
        @param deviceName: DeviceName can be "AC5", "AC5X", "AC5P", "IM_L", "IM_M" or "TL10"
        @return:
        """

        try:
            if self.log_level == 1:
                msg = f"Try to execute cmis_set_diagnostics. module_number is {module_numbe}, prbs_type is {prbs_type},startOrStop is {startOrStop}  deviceName={deviceName}"
                print(debug(msg))
            rc, resData = self._handle.cmis_set_diagnostics(module_numbe, prbs_type, startOrStop, deviceName)
            if not rc:
                raise Exception(f"Dailed to execute cmis_set_diagnostics. module_number is {module_numbe}, prbs_type is {prbs_type},startOrStop is {startOrStop}  deviceName={deviceName}")
            if self.log_level == 1:
                msg = f"Try to execute cmis_set_diagnostics , success."
                print(debug(msg))
            return resData
        except Exception as e:
            raise Exception(f"Failed to execute cmis_set_diagnostics .\n Error: {str(e)}")

