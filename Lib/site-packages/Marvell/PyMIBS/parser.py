import re
from Marvell.PyMIBS.Common.utilities import debug, RetElement


class parser(object):

    def __init__(self):
        self.scan_regex = re.compile(r'(?<=at address )0x[0-9a-fA-F]+')
        self.hex_pattern = re.compile(r"(?<=\n)[0-9a-fx ]+")

        self.scan_status_pattern = r"Detected I2C device"
        # self.read_status_pattern = r"I2C Bus Read Successful"
        self.read_status_pattern = r"I2C Bus Read  Successful"
        # self.write_success_pattern = r"I2C Bus Write Successful"
        self.write_success_pattern = r"I2C Bus  Write Successful"
        self.write_read_success_pattern = "I2C Bus Read Write Successful"
        self._log = 0

    def setLog(self, logLevel: int):
        self._log = logLevel

    def parse_hostport(self, hp: str):
        if not hp.rsplit(':', 1)[-1].isdigit():
            return hp, None

        hp = hp.rsplit(':', 1)

        host = hp[0]  # 1st index is always host
        port = int(hp[1])

        return host, port

    def parse_i2c_read(self, data):
        # Match the status
        status_match = re.search(self.read_status_pattern, data)
        if status_match is None:
            return False, None

        # Match the hex numbers
        hex_match = re.findall(self.hex_pattern, data)
        if hex_match:
            if len(hex_match[0].split()) > 1:
                hex_strings = hex_match[0].split()
            elif len(hex_match) > 1 and len(hex_match[1].split()) > 1:
                hex_strings = hex_match[1].split()
            else:
                hex_strings = []
        else:
            hex_strings = []

        if self._log == 1:
            print(debug(f"Parse Read: {hex_strings}"))

        # Convert hex strings to integers
        hex_numbers = [int(hex_string, 16) for hex_string in hex_strings]
        # hex_list = [hex(number) for number in hex_numbers]

        return True, hex_numbers

    def parse_i2c_write_read(self, data):
        # Match the status
        status_match = re.search(self.write_read_success_pattern, data)
        if status_match is None:
            return False, None

        # Match the hex numbers
        # hex_match = re.search(self.hex_pattern, data)
        # hex_strings = hex_match.group().split() if hex_match else []

        hex_match = re.findall(self.hex_pattern, data)
        if hex_match == []:
            return False, None
        hex_strings = hex_match[-1].split() if hex_match else []

        if self._log == 1:
            print(debug(f"Parse Write-Read: {hex_strings}"))

        # Convert hex strings to integers
        hex_numbers = [int(hex_string, 16) for hex_string in hex_strings]

        return True, hex_numbers

    def parse_i2c_write(self, data):
        success_match = re.search(self.write_success_pattern, data)
        write_success = success_match is not None
        if self._log == 1:
            print(debug(f"Parse Write: {write_success}"))

        return write_success

    def parse_i2c_scan(self, data):
        # Match the status
        status_match = re.search(self.scan_status_pattern, data)
        if status_match is None:
            return False, None

        addresses = self.scan_regex.findall(data)

        if self._log == 1:
            print(print(debug(f"Parse Scan: {addresses}")))

        int_addresses = [int(hex_string, 16) for hex_string in addresses]
        return True, int_addresses

    def parse_generic_output(self, data):
        lines = data.strip().split('\n')
        pattern = r'=(\S+)'

        output = []
        for line in lines:
            values = re.findall(pattern, line)
            if len(values) == 4:
                output.append(list(values))
        return output

    def parse_return_element(self, output, funcName, key_=None):
        if len(output) == 0:
            return False, None

        retList = {}
        for val in output:
            if '.' in val[3]:
                value = float(val[3])
            elif val[3].isnumeric():
                value = int(val[3])
            elif '0x' in val[3]:
                value = int(val[3], 16)
            else:
                value = val[3]
            key = int(val[2]) if key_ == None else key_
            retList[key] = RetElement(int(val[0], 16), val[1] if val[1] == "None" else int(val[1], 16), value)

        if self._log == 1:
            print(print(debug(f"{funcName}: {retList}")))

        return True, retList

    def parse_temp_read_all(self, data):
        output = self.parse_generic_output(data)
        return self.parse_return_element(output, "parse temp read all")

    def parse_temp_read_specific(self, data):
        output = self.parse_generic_output(data)
        return self.parse_return_element(output, "parse temp read specific")

    def parse_fan_error(self, data):
        output = self.parse_generic_output(data)
        return self.parse_return_element(output, "parse fan error")

    def parse_fan_control(self, data):
        output = self.parse_generic_output(data)
        # return self.parse_return_element(output, "parse fan control", key_='0x1f')
        return self.parse_return_element(output, "parse fan control", key_=31)

    def parse_fan_read_all(self, data):
        output = self.parse_generic_output(data)
        return self.parse_return_element(output, "parse fan read all")

    def parse_fan_read_specific(self, data):
        output = self.parse_generic_output(data)
        return self.parse_return_element(output, "parse fan read specific")

    def parse_fan_write_specific(self, data):
        output = self.parse_generic_output(data)
        return self.parse_return_element(output, "parse fan write specific")

    def parse_fan_write_multiple(self, data):
        output = self.parse_generic_output(data)
        return self.parse_return_element(output, "parse fan write multiple")

    def parse_fpga_read(self, data):
        output = self.parse_generic_output(data)
        return self.parse_return_element(output, "parse fpga read")

    def parse_fpga_write(self, data):
        output = self.parse_generic_output(data)
        return self.parse_return_element(output, "parse fpga write")

    def parse_em_output(self, data, funcName: str):
        lines = data.strip().split('\n')
        if len(lines) < 3:
            return False, None
        pattern = r'successful\s+(\d+(?:\.\d+)?)'
        match = re.search(pattern, lines[2])
        if match:
            if self._log == 1:
                print(print(debug(f"{funcName}: {float(match.group(1))}")))
            return True, float(match.group(1))
        else:
            return False, None

    def parse_em_set_vdd(self, data):
        return self.parse_em_output(data, "parse em set vdd")

    def parse_em_get_vdd(self, data):
        return self.parse_em_output(data, "parse em get vdd")

    def parse_em_get_idd(self, data):
        return self.parse_em_output(data, "parse em get idd")

    def parse_cmis_get_vendor_name(self, data):
        if re.search("mibs_cmis_client: not found", data) is not None or re.search("failed", data) is not None:
            return False, None

        # Define the regex patterns to match the desired values
        pattern_name = r'CMIS Vendor Name\s+=\s+(.*)$'
        pattern_part_number = r'CMIS Vendor Part Number\s+=\s+(.*)$'
        pattern_revision = r'CMIS Vendor Revision\s+=\s+(.*)$'
        pattern_serial_number = r'CMIS Vendor Serial Number\s+=\s+(.*)$'

        # Find the matches using the regex patterns
        name_match = re.search(pattern_name, data, re.MULTILINE)
        part_number_match = re.search(pattern_part_number, data, re.MULTILINE)
        revision_match = re.search(pattern_revision, data, re.MULTILINE)
        serial_number_match = re.search(pattern_serial_number, data, re.MULTILINE)

        # Extract the values from the matches
        name = name_match.group(1).strip() if name_match else ''
        part_number = part_number_match.group(1).strip() if part_number_match else ''
        revision = revision_match.group(1).strip() if revision_match else ''
        serial_number = serial_number_match.group(1).strip() if serial_number_match else ''

        res = {
            "Name": name,
            "PartNumber": part_number,
            "Revision": revision,
            "SerialNumber": serial_number
        }
        if self._log == 1:
            print(print(debug(f"parse cmis get vendor name: {res}")))
        return True, res

    def parse_cmis_get_temperature(self, data):
        if re.search("mibs_cmis_client: not found", data) is not None or re.search("failed", data) is not None:
            return False, None

        pattern_temperature = r'CMIS Module Temperature\s+=\s+(\S+)'
        temperature_match = re.search(pattern_temperature, data, re.MULTILINE)
        temperature = temperature_match.group(1).strip() if temperature_match else ''

        res = float(temperature)
        if self._log == 1:
            print(print(debug(f"parse cmis get temperature: {res}")))
        return True, res

    def parse_cmis_get_rx_cdr_lol(self, data):
        if re.search("mibs_cmis_client: not found", data) is not None or re.search("failed", data) is not None:
            return False, None

        pattern = r'RX CDR Lane (\d+) Status = (\d+)'

        matches = re.findall(pattern, data)
        lane_status_dict = {int(lane): int(status) for lane, status in matches}
        return True, lane_status_dict

    def parse_lane_disable_status(self, data, funcName: str):
        if re.search("mibs_cmis_client: not found", data) is not None or re.search("failed", data) is not None:
            return False, None

        pattern_lane_disable_status = r'Lane Disable Status\s+=\s+(\S+)'
        lane_disable_status_match = re.search(pattern_lane_disable_status, data, re.MULTILINE)
        lane_disable_status = lane_disable_status_match.group(1).strip() if lane_disable_status_match else ''

        res = int(lane_disable_status, 16)
        if self._log == 1:
            print(print(debug(f"{funcName}: {res}")))
        return True, res

    def parse_cmis_get_tx_disable(self, data):
        return self.parse_lane_disable_status(data, "parse cmis get tx disable")

    def parse_cmis_set_tx_disable(self, data):
        return self.parse_lane_disable_status(data, "parse cmis set tx disable")

    def parse_tx_fir(self, data, funcName: str):
        if re.search("mibs_cmis_client: not found", data) is not None or re.search("failed", data) is not None:
            return False, None

        pattern = r'RX (\w+)\s+\[Lane (\d+)\] = (\w+)'

        matches = re.findall(pattern, data)
        lane_data_dict = {}

        for word, lane, value in matches:
            lane_num = int(lane)
            data_value = int(value, 16)
            if lane_num not in lane_data_dict:
                lane_data_dict[lane_num] = {}
            lane_data_dict[lane_num][word] = data_value

        if self._log == 1:
            print(print(debug(f"{funcName}: {lane_data_dict}")))

        return True, lane_data_dict

    def parse_cmis_get_tx_fir(self, data):
        return self.parse_tx_fir(data, "parse cmis get tx fir")

    def parse_cmis_set_tx_fir(self, data):
        return self.parse_tx_fir(data, "parse cmis set tx fir")

    def parse_register_value(self, data):
        if re.search("mibs_cmis_client: not found", data) is not None or re.search("failed", data) is not None:
            return False, None

        pattern = r'Read (\w+) from module = (\w+) page = (\w+) bank = (\w+) offset = (\w+)'
        match = re.search(pattern, data)
        res = {
            'RegisterValue': int(match.group(1), 16),
            'Module': int(match.group(2)),
            'Page': int(match.group(3), 16),
            'Bank': int(match.group(4)),
            'Offset': int(match.group(5))
        }
        if self._log == 1:
            print(print(debug(f"parse cmis register value: {res}")))
        return True, res

    def parse_cmis_get_register(self, data):
        return self.parse_register_value(data)

    def parse_cmis_set_register(self, data):
        return self.parse_register_value(data)

    def parse_cmis_get_loopback_capabilities(self, data):
        if re.search("mibs_cmis_client: not found", data) is not None or re.search("failed", data) is not None:
            return False, None
        # TODO CHEN
        res = data
        if self._log == 1:
            print(print(debug(f"parse cmis get loopback capabilities: {res}")))
        return True, res


    def parse_cmis_set_loopback(self, data):
        if re.search("mibs_cmis_client: not found", data) is not None or re.search("failed", data) is not None:
            return False, None

        # TODO CHEN
        res = data
        if self._log == 1:
            print(print(debug(f"parse cmis set loopback: {res}")))
        return True, res

    def parse_cmis_get_diagnostics_capabilities(self, data):
        if re.search("mibs_cmis_client: not found", data) is not None or re.search("failed", data) is not None:
            return False, None

        # TODO CHEN
        res = data
        if self._log == 1:
            print(print(debug(f"parse cmis get diagnostics capabilities: {res}")))
        return True, res

    def parse_cmis_set_diagnostics(self, data):
        if re.search("mibs_cmis_client: not found", data) is not None or re.search("failed", data) is not None:
            return False, None

        # TODO CHEN
        res = data
        if self._log == 1:
            print(print(debug(f"parse cmis set diagnostics: {res}")))
        return True, res
