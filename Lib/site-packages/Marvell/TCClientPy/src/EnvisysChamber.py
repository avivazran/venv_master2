from builtins import object
from .FlexMaxTC import *
from time import sleep
from pyModbusTCP.client import ModbusClient


TEMPERATURE_READ_REG_ADDRESS = 0xA
TEMPERATURE_SET_POINT_REG_ADDRESS = 0x13
RAMP_RATE_SET_POINT_REG_ADDRESS = 0x15
STATUS_REG_ADDRESS = 0xC

def operand_to_decimal(operand):
    if operand > (1 << 16) / 2:
        operand -= (1 << 16)
    return float(operand) / 10

def float_to_signed_int(operand):
    if operand < 0:
        operand = int(operand * 10)
        operand += (1 << 16)
        return operand
    return int(operand * 10)


def check_status(client):
    status = client.read_holding_registers(STATUS_REG_ADDRESS)
    if not status:
        raise Exception("Unexpected error, please make sure that the TC connected properly and try again.")
    if status[0] != 1:
        raise Exception("Unable to set temperature when not in manual mode!")


class EnvisysChamber(object):


    def __init__(self, tc_ip, port=502, debug=False):
        self.modbus_client = ModbusClient(host=tc_ip, port=port, debug=debug)
        try:
            res = self.modbus_client.open()
            if not res:
                raise Exception("EnvisysTC connection failed")
        except Exception as e:
            raise Exception(str(e))

    def disconnect(self):
        if self.modbus_client:
            self.modbus_client.close()
            self.modbus_client = None


    def get_set_manual_ramp(self,channel,  ramp):
        if self.modbus_client:
            check_status(self.modbus_client)
            self.modbus_client.write_single_register(RAMP_RATE_SET_POINT_REG_ADDRESS, float_to_signed_int(ramp))
        else:
            raise Exception("You are not connected to the TC")


    def get_set_setpoint(self,channel, setpoint = None):
        if not setpoint:
            return self.get_current_setpoint()
        if self.modbus_client:
            # if setpoint > 100 or setpoint < -10:
            #     raise Exception("Target temperature outside of allowed range!")

            self.modbus_client.write_single_register(TEMPERATURE_SET_POINT_REG_ADDRESS, float_to_signed_int(setpoint))

        else:
            raise Exception("You are not connected to the TC")


    def get_current_setpoint(self):
        if self.modbus_client:
            setpoint_res = self.modbus_client.read_holding_registers(TEMPERATURE_SET_POINT_REG_ADDRESS)
            setpoint = None
            if setpoint_res:
                setpoint = operand_to_decimal(setpoint_res[0])
            return setpoint
        else:
            return None


    # def set_temperature(self, target_temperature, ramp_rate=0.1):
    #     if self.modbus_client:
    #         status = check_status(self.modbus_client)
    #         if not status:
    #             raise Exception("Unexpected error, please make sure that the TC connected properly and try again.")
    #         if status[0] != 1:
    #             raise Exception("Unable to set temperature when not in manual mode!")
    #         if target_temperature > 100 or target_temperature < -10:
    #             raise Exception("Target temperature outside of allowed range!")
    #         self.modbus_client.write_single_register(RAMP_RATE_SET_POINT_REG_ADDRESS, float_to_signed_int(ramp_rate))
    #         self.modbus_client.write_single_register(TEMPERATURE_SET_POINT_REG_ADDRESS, float_to_signed_int(target_temperature))
    #     else:
    #         raise Exception("You are not connected to the TC")


    def get_process_variable(self, channel):
        if self.modbus_client:
            temp_res = self.modbus_client.read_holding_registers(TEMPERATURE_READ_REG_ADDRESS)
            temp = None
            if temp_res:
                temp = operand_to_decimal(temp_res[0])
            else:
                raise Exception("Unexpected error, please make sure that the TC is on and try again.")
            return temp
        else:
            return None

    # def wait_for_temp(self, temp, temp_deviation, stable_samples_target=STABLE_SAMPLE_NUM, wait_timeout=WAIT_TIMEOUT):
    #     stable_samples = 0
    #     total_time = 0
    #
    #     curr_temp = self.get_current_temperature()
    #
    #     while True:
    #         if abs(curr_temp - temp) <= temp_deviation:
    #             stable_samples += 1
    #         else:
    #             stable_samples = 0
    #
    #         if total_time >= wait_timeout or stable_samples >= stable_samples_target:
    #             break
    #
    #         sleep(self.SAMPLE_DELAY)
    #         total_time += self.SAMPLE_DELAY
    #
    #         curr_temp = self.get_current_temperature()
    #
    #     if total_time >= wait_timeout:
    #         raise Exception("Timeout waiting for target temperature")


    def get_mode(self):
        if self.modbus_client:
            power_res = self.modbus_client.read_coils(1)
            if power_res:
                return 1 if power_res[0] else 0
            else:
                raise Exception("Unexpected error, please make sure that the TC connected properly and try again.")
        else:
            raise Exception("You are not connected to the TC")


    def set_manual_run(self):
        if self.modbus_client:
            self.modbus_client.write_single_coil(1, True)
        else:
            raise Exception("You are not connected to the TC")

    def set_stop(self):
        if self.modbus_client:
            self.modbus_client.write_single_coil(1, False)
        else:
            raise Exception("You are not connected to the TC")

