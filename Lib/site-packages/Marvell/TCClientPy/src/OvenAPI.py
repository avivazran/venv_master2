'''
Test: Contains TC related functions
'''
from __future__ import print_function
from builtins import object
import time
from .ThermotronChamber import *
from .EnvisysChamber import *
from .enumOvenType import OvenTypeEnum as Type

class OvenAPI(object):
    WAIT_TIMEOUT = 300  # sec
    SAMPLE_DELAY = 5  # sec
    STABLE_SAMPLE_NUM = 10

    def __init__(self, type=Type.THERMOTRON):
        self.type = type
        self.tc_oven = None

    def tc_connect(self, tc_ip):
        try:
            if self.type == Type.ENVISYS:
                self.tc_oven = EnvisysChamber(tc_ip)
            else:
                self.tc_oven = ThermotronChamber(tc_ip)
        except Exception as e:
            raise Exception("CHAMBER Connection: " + str(e))

    def tc_disconnect(self):
        if self.tc_oven:
            self.tc_oven.disconnect()
            self.tc_oven = None

    def set_temperature(self, target_temperature, ramp_time=300):
        if self.tc_oven is not None:
            try:
                self.tc_oven.set_stop()
                print("stop chamber")
                self.tc_oven.get_set_manual_ramp(channel=1, ramp=ramp_time)
                print("set chamber ramp")
                self.tc_oven.get_set_setpoint(channel=1, setpoint=target_temperature)
                print("set chamber setpoint")
                self.tc_oven.set_manual_run()
                print("run chamber")
                time.sleep(1)
            except Exception as e:
                raise Exception("TC temperature_Setting : " + str(e))
        else:
            raise Exception("The oven is not connected")

    def read_temperature(self):
        if self.tc_oven is not None:
            temp = self.tc_oven.get_process_variable(1)
            if temp is None:
                raise Exception("The oven is not connected or there might be some other error")
            return float(temp)
        else:
            raise Exception("The oven is not connected")



    def wait_for_temp(self, temp, temp_deviation, stable_samples_target=STABLE_SAMPLE_NUM, wait_timeout=WAIT_TIMEOUT):
        stable_samples = 0
        total_time = 0

        curr_temp = self.read_temperature()

        while True:
            if abs(curr_temp - temp) <= temp_deviation:
                stable_samples += 1
            else:
                stable_samples = 0

            if total_time >= wait_timeout or stable_samples >= stable_samples_target:
                break

            sleep(self.SAMPLE_DELAY)
            total_time += self.SAMPLE_DELAY

            curr_temp = self.read_temperature()

        if total_time >= wait_timeout:
            raise Exception("Timeout waiting for target temperature")


    def get_setpoint(self):
        if self.tc_oven is not None:
            setpoint = self.tc_oven.get_set_setpoint(channel=1)
            if setpoint == None:
                setpoint = self.tc_oven.get_set_setpoint(channel=1)
                if setpoint == None:
                    raise Exception("The oven is not connected or there might be some other error")
            if self.type == Type.THERMOTRON:
                setpoint = setpoint.split('\r')[-1]  # There is sometimes more than one value
            return float(setpoint)
        else:
            raise Exception("The oven is not connected")

    def get_power_mode(self):
        return int(self.tc_oven.get_mode())

    def turn_power_on_off(self, is_on=True):
        if is_on:
            self.tc_oven.set_manual_run()
        else:
            self.tc_oven.set_stop()


    def set_oven_type(self, type):
        if type not in Type.values():
            raise "This oven type does not exist in the system!"
        if type != self.type:
            self.tc_disconnect()
            self.type = type
