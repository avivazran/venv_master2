from builtins import bytes, str, object
import socket
import select
import time


class FlexMaxTC(object):
    def __init__(self, ip_addr, tcp_port=5000, timeout_secs=3):
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.ip = ip_addr
        self.tcp = tcp_port
        self.to = timeout_secs
        self.baseCommand = "m"
        self.rxbufsize = 1024
        self.read_all_at_once = True

    def connect(self):
        self.s.setblocking(0)
        self.s.settimeout(self.to)
        self.s.connect((self.ip, self.tcp))

    def disconnect(self):
        if self.s is not None:
            self.s.shutdown(2)
            self.s.close()

    def check_connection(self):
        if self.s is None:
            raise OSError('Socket error; not connected')

    # Send command string to connected socket
    def send(self, command):
        self.check_connection()

        buf = bytes(command, 'utf-8')
        try:
            self.s.sendall(buf)
        except OSError as e:
            raise OSError("Socket error; send failure (sending \'%s\')" % command.strip())

    # Receive response from connected socket
    def receive(self):
        self.check_connection()

        bytes_arr = bytearray()
        while True:
            try:
                readable, writeable, error = select.select([self.s], [], [], self.to)
            except Exception as e:
                raise OSError("Socket error; read failure")

            if readable:
                data = self.s.recv(self.rxbufsize)

                if not data:
                    raise OSError('Socket error; no data on readable socket')
                else:
                    bytes_arr += data
                    if self.read_all_at_once:
                        break
            else:
                break

        response = bytes_arr.decode().rstrip('\r\n')
        return response

    def transact(self, command):
        response = None

        while response is None:
            try:
                self.send(command)
                response = self.receive()
            except Exception as e1:
                print(str(e1))
                print("Disconnecting...")
                self.disconnect()
                time.sleep(5)
                self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

                try:
                    print("Reconnecting...")
                    self.connect()
                except Exception as e:
                    self.s.close()
                    self.s = None
                    print(str(e))

        return response

    # Read MI Register from machine
    def ReadMI(self, address):
        self.check_connection()
        command = "MI" + address + "?"
        self.transact(self.baseCommand)
        return self.transact(command)

    # Read MB Register from machine
    def ReadMB(self, address):
        self.check_connection()
        command = "MB" + address + "?"
        self.transact(self.baseCommand)
        return self.transact(command)

    # Write MI Register with specified value
    def WriteMI(self, address, value):
        self.check_connection()
        command = "MI" + address + "," + str(value)
        self.transact(self.baseCommand)
        return self.transact(command)

    # Write MB Register with specified value
    def WriteMB(self, address, value):
        self.check_connection()
        command = "MB" + address + "," + str(value)
        self.transact(self.baseCommand)
        return self.transact(command)

    # Get the value from a read command
    def get_val(self, raw_val):
        return raw_val.split(',')[1]

    # Convert a decimal number to a string - "XXXX", padded with 0's, one decimal digit in the end
    def decimal_to_operand(self, decimal, is_float=True):
        return "{:04d}".format(int(decimal * (10 if is_float else 1)))

    # Convert a "XXXX" string to a decimal number
    def operand_to_decimal(self, operand):
        return float(operand) / 10
