from __future__ import print_function
from builtins import range
import inspect


class BaseInfraException(Exception):
    def __init__(self, message=None):
        super(self.__class__, self).__init__(message)

    @staticmethod
    def get_logger_from_class(class_obj):
        return getattr(class_obj, 'logger', None)

    @staticmethod
    def get_class_from_frame():
        instance = None
        for i in range(1, len(inspect.stack())):
            fr = inspect.stack()[i][0]
            args, _, _, value_dict = inspect.getargvalues(fr)
            # we check the first parameter for the frame function is
            # named 'self'
            if len(args) and args[0] == 'self':
                # in that case, 'self' will be referenced in value_dict
                instance = value_dict.get('self', None)
                if not issubclass(instance.__class__, BaseInfraException):
                    break

        # return its class
        # return None otherwise
        return instance


class LoggedException(BaseInfraException):
    def __init__(self, message=None):
        super(BaseInfraException, self).__init__(message)

        caller = self.get_class_from_frame()

        caller_logger = self.get_logger_from_class(caller)
        if caller_logger is not None:
            caller_logger.exception(message)
        else:
            print("Caller has not logger")
